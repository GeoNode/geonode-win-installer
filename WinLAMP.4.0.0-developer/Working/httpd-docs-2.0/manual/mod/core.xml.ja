<?xml version="1.0" encoding="iso-2022-jp"?>
<!DOCTYPE modulesynopsis SYSTEM "../style/modulesynopsis.dtd">
<?xml-stylesheet type="text/xsl" href="../style/manual.ja.xsl"?>
<!-- English Revision: 106090:396609 (outdated) -->

<!--
 Copyright 2003-2004 The Apache Software Foundation

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->

<modulesynopsis metafile="core.xml.meta">

<name>core</name>
<description>常に使用可能な Apache HTTP サーバのコア機能</description>
<status>Core</status>

<directivesynopsis>
<name>AcceptPathInfo</name>
<description>後に続くパス名情報を受け付けるリソースの指定</description>    
<syntax>AcceptPathInfo On|Off|Default</syntax>
<default>AcceptPathInfo Default</default>
<contextlist><context>server config</context>
<context>virtual host</context><context>directory</context>
<context>.htaccess</context></contextlist>
<override>FileInfo</override>
<compatibility>Apache 2.0.30 以降で使用可能</compatibility>

<usage>

    <p>このディレクティブは実際のファイル名 (もしくは存在するディレクトリの
    存在しないファイル) の後に続くパス名情報があるリクエストを受け付けるか
    拒否するかを制御します。続きのパス名情報はスクリプトには <code>PATH_INFO</code>
    環境変数として利用可能になります。</p>

    <p>例えば、<code>/test/</code> が、<code>here.html</code> というファイル
    一つのみがあるディレクトリを指しているとします。そうすると、
    <code>/test/here.html/more</code> と <code>/test/nothere.html/more</code>
    へのリクエストは両方とも <code>/more</code> を <code>PATH_INFO</code> とします。</p>

    <p><directive>AcceptPathInfo</directive> ディレクティブに指定可能な
    三つの引数は:</p>

    <dl>
    <dt><code>Off</code></dt><dd>リクエストは存在するパスにそのまま
    マップされる場合にのみ受け付けられます。ですから、上の例の
    <code>/test/here.html/more</code> のように、本当のファイル名の
    後にパス名情報が続くリクエストには 404 NOT FOUND エラーが返ります。</dd>

    <dt><code>On</code></dt><dd>前の方のパスが存在するファイルにマップする場合は
    リクエストが受け付けられます。上の例の <code>/test/here.html/more</code>
    は <code>/test/here.html</code> が有効なファイルにマップすれば
    受け付けられます。</dd>
    
    <dt><code>Default</code></dt><dd>続きのパス名情報の扱いはリクエストの
    <a href="../handler.html">ハンドラ</a>で決まります。
    普通のファイルのためのコアハンドラのデフォルトは <code>PATH_INFO</code> を拒否します。
    <a href="mod_cgi.html">cgi-script</a> や <a
    href="mod_isapi.html">isapi-isa</a> のようにスクリプトを扱うハンドラは
    一般的にデフォルトで <code>PATH_INFO</code> を受け付けます。</dd>
    </dl>

    <p><code>AcceptPathInfo</code> の主な目的はハンドラの <code>PATH_INFO</code> を
    受け付けるか拒否するかの選択を上書きできるようにすることです。
    例えば、これは例えば <a href="mod_include.html">INCLUDES</a> のような
    <a href="../filter.html">フィルタ</a>を使って <code>PATH_INFO</code> に
    基づいてコンテンツを生成しているときに必要になります。</p>

    <example>
      &lt;Files "mypaths.shtml"&gt;<br />
      <indent>
        Options +Includes<br />
        SetOutputFilter INCLUDES<br />
        AcceptPathInfo On<br />
      </indent>
      &lt;/Files&gt;
    </example>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>AccessFileName</name>
<description>分散設定ファイルの名前</description>
<syntax>AccessFileName <var>filename</var> [<var>filename</var>] ...</syntax>
<default>AccessFileName .htaccess</default>
<contextlist><context>server config</context><context>virtual host</context>
</contextlist>

<usage>
    <p>リクエストを処理するとき、サーバはディレクトリに
    対して分散設定ファイルが<a href="#allowoverride">有効になっていれば</a>、
    そのドキュメントへの
    パス上にある全てのディレクトリから、ここで指定された名前の一覧の中で
    最初に見つかったファイルをそれぞれ設定ファイルとして読み込みます。例えば:</p>

    <example>
      AccessFileName .acl
    </example>

    <p>という設定があると、以下のようにして無効にされていない限り、
    ドキュメント <code>/usr/local/web/index.html</code>
    を返す前に、サーバは <code>/.acl</code>, <code>/usr/.acl</code>,
    <code>/usr/local/.acl</code>, <code>/usr/local/web/.acl</code> から
    ディレクティブを読み込みます。</p>

    <example>
      &lt;Directory /&gt;<br />
      <indent>
        AllowOverride None<br />
      </indent>
      &lt;/Directory&gt;
    </example>
</usage>
<seealso><directive module="core">AllowOverride</directive></seealso>
<seealso><a href="../configuring.html">設定ファイル</a></seealso>
<seealso><a href="../howto/htaccess.html">.htaccess ファイル</a></seealso>
</directivesynopsis>

<directivesynopsis>
<name>AddDefaultCharset</name>
<description>明示的に文字セットを指定していない応答に追加される
デフォルトの文字セット</description>
<syntax>AddDefaultCharset On|Off|<var>charset</var></syntax>
<default>AddDefaultCharset Off</default>
<contextlist><context>server config</context>
<context>virtual host</context><context>directory</context>
<context>.htaccess</context></contextlist>
<override>FileInfo</override>

<usage>
    <p>このディレクティブは、HTTP ヘッダにコンテントタイプパラメータを
    持たない応答に追加される文字セットの名前を指定します。
    これは、ドキュメント内の META タグで指定されたどのような文字セット
    も無効にします。
    <code>AddDefaultCharset Off</code> という設定により、この機能は無効になります。
    <code>AddDefaultCharset On</code> にすれば、ディレクティブの要求通り
    Apache 内部のデフォルト文字セット <code>iso-8859-1</code> に設定します。
    また、他の <var>charset</var> も指定できます。例えば:</p>

    <example>
      AddDefaultCharset utf-8
    </example>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>AddOutputFilterByType</name>
<description>MIME-type に出力フィルタを割り当てる</description>
<syntax>AddOutputFilterByType <var>filter</var>[;<var>filter</var>...] <var>MIME-type</var>
[<var>MIME-type</var>] ...</syntax>
<contextlist><context>server config</context>
<context>virtual host</context><context>directory</context>
<context>.htaccess</context></contextlist>
<override>FileInfo</override>
<compatibility>Apache 2.0.33 以降で使用可能</compatibility>

<usage>
    <p>このディレクティブは応答の MIME-type に応じて出力<a
    href="../filter.html">フィルタ</a>を使用するようにします。</p>

    <p>次の例は <module>mod_deflate</module> の <code>DEFLATE</code> フィルタを
    使っています。<code>text/html</code> と <code>text/plain</code> の
    すべての出力 (静的なものも動的なものも) をクライアントに送られる前に
    圧縮します。</p>

    <example>
      AddOutputFilterByType DEFLATE text/html text/plain
    </example>

    <p>複数のフィルタでコンテンツを処理させたいときは、それぞれの名前をセミコロンで
    分ける必要があります。各フィルタに対して
    <directive>AddOutputFilterByType</directive> を一つずつ書くこともできます。</p>

    <p>次の例は <code>text/html</code> のスクリプトのすべての出力を
    まず <code>INCLUDES</code> フィルタで処理し、さらに <code>DEFLATE</code> フィルタにかけます。</p>

    <example>
    &lt;Location /cgi-bin/&gt;<br />
    <indent>
      Options Includes<br />
      AddOutputFilterByType INCLUDES;DEFLATE text/html<br />
    </indent>
    &lt;/Location&gt;
    </example>

    <note type="warning"><title>注:</title>
      <p><directive>AddOutputFilterByType</directive> ディレクティブにより
      有効にしたフィルタは場合によっては、部分的もしくは完全に適用されないことが
      あります。例えば、MIME タイプがが決定できないときには
      <directive module="core">DefaultType</directive> の設定が同じだったとしても、
      <directive module="core">DefaultType</directive> 設定を使うようになります。</p>
      <p>しかし、確実にフィルタが適用されるようにしたいときは、リソースに
      明示的にコンテントタイプを割り当てることができます。これには例えば
      <directive module="mod_mime">AddType</directive> ディレクティブや
      <directive module="core">ForceType</directive> ディレクティブを使います。
      (nphでない) CGI スクリプトでコンテントタイプを設定するというものでも
      大丈夫です。</p>

      <p>タイプ毎の出力フィルタはプロキシリクエストには決して適用されません。</p>
    </note>
</usage>

<seealso><directive module="mod_mime">AddOutputFilter</directive></seealso>
<seealso><directive module="core">SetOutputFilter</directive></seealso>
<seealso><a href="../filter.html">フィルタ</a></seealso>
</directivesynopsis>

<directivesynopsis>
<name>AllowEncodedSlashes</name>
<description>URL 中の符号化されたパス分離文字が先に伝えられるのを許可するかどうかを
決定する</description>
<syntax>AllowEncodedSlashes On|Off</syntax>
<default>AllowEncodedSlashes Off</default>
<contextlist><context>server config</context><context>virtual host</context>
</contextlist>
<compatibility>Apache 2.0.46 以降で使用可能</compatibility>

<usage>
    <p><directive>AllowEncodedSlashes</directive> ディレクティブは符号化された
    パス分離文字 (<code>/</code> は <code>%2F</code>、さらにシステムによっては
    <code>\</code> に対応する <code>%5C</code>) が存在する URL の使用を
    許可するかどうかを決定します。通常はそのような URL は 404 (Not found) エラー
    で拒否されます。</p>

    <p><directive>AllowEncodedSlashes</directive> <code>On</code> による
    パス分離文字の使用は、<code>PATH_INFO</code> と合わせて
    使うときに一番役に立ちます。</p>
    <p>Turning <directive>AllowEncodedSlashes</directive> <code>On</code> is
    mostly useful when used in conjunction with <code>PATH_INFO</code>.</p>

    <note><title>注</title>
      <p>符号化されたスラッシュを許可することは、<em>復号</em>をすることを
       意味<em>しません</em>。<code>%2F</code> や (関係するシステムでの)
       <code>%5C</code> は、他の部分が復号された URL の中でもそのままの形式で
       残されます。</p>
    </note>
</usage>
<seealso><directive module="core">AcceptPathInfo</directive></seealso>
</directivesynopsis>


<directivesynopsis>
<name>AllowOverride</name>
<description><code>.htaccess</code> で許可されるディレクティブの種類</description>
<syntax>AllowOverride All|None|<var>directive-type</var> 
[<var>directive-type</var>] ...</syntax>
<default>AllowOverride All</default>
<contextlist><context>directory</context></contextlist>

<usage>
    <p>サーバが (<directive
    module="core">AccessFileName</directive> によって指定された)
    .htaccess ファイルを見つけた時、そのファイルの中で
    宣言されたどのディレクティブがより前に定義された設定ディレクティブを
    上書きできるかを知る必要があります。</p>

    <note><title>&lt;Directory&gt; セクションでのみ使用可能</title>
    <directive>AllowOverride</directive> は正規表現無しの<directive
    type="section" module="core">Directory</directive>
    セクションでのみ有効で、<directive type="section"
    module="core">Location</directive> や <directive
    module="core" type="section">DirectoryMatch</directive>
    や <directive type="section"
    module="core">Files</directive> セクションでは無効です。
    </note>

    <p>このディレクティブを None に設定すると、<a href="#accessfilename">.htaccess</a> ファイルは完全に
    無視されます。
    この場合、サーバはファイルシステムの <code>.htaccess</code> ファイルを読むことを
    試みさえしません。</p>

    <p>このディレクティブが <code>All</code> に設定されている時には、
    <code>.htaccess</code> という <a
    href="directive-dict.html#Context">コンテキスト</a> を持つ
    全てのディレクティブが利用できます。</p>

    <p><var>directive-type</var> には、以下のディレクティブ群の
    キーワードのどれかを指定します。</p>

    <dl>
      <dt>AuthConfig</dt>

      <dd>

      認証に関するディレクティブの使用を許可する (<directive
      module="mod_auth_dbm">AuthDBMGroupFile</directive>,
      <directive module="mod_auth_dbm">AuthDBMUserFile</directive>,
      <directive module="mod_auth">AuthGroupFile</directive>,
      <directive module="core">AuthName</directive>, 
      <directive module="core">AuthType</directive>, <directive
      module="mod_auth">AuthUserFile</directive>, <directive
      module="core">Require</directive> <em>など。</em>)。</dd>

      <dt>FileInfo</dt>

      <dd>
      ドキュメントタイプを制御するためのディレクティブの使用を許可する (<directive
      module="core">DefaultType</directive>, <directive
      module="core">ErrorDocument</directive>, <directive
      module="core">ForceType</directive>, <directive
      module="mod_negotiation">LanguagePriority</directive>,
      <directive module="core">SetHandler</directive>, <directive
      module="core">SetInputFilter</directive>, <directive
      module="core">SetOutputFilter</directive>, 
      <module>mod_mime</module> の Add* と Remove*
      ディレクティブ<em>など。</em>)。</dd>

      <dt>Indexes</dt>

      <dd>
      ディレクトリインデックスを制御するためのディレクティブの使用を許可する
      (<directive
      module="mod_autoindex">AddDescription</directive>,
      <directive module="mod_autoindex">AddIcon</directive>, <directive
      module="mod_autoindex">AddIconByEncoding</directive>,
      <directive module="mod_autoindex">AddIconByType</directive>,
      <directive module="mod_autoindex">DefaultIcon</directive>, <directive
      module="mod_dir">DirectoryIndex</directive>, <directive
      module="mod_autoindex">FancyIndexing</directive>, <directive
      module="mod_autoindex">HeaderName</directive>, <directive
      module="mod_autoindex">IndexIgnore</directive>, <directive
      module="mod_autoindex">IndexOptions</directive>, <directive
      module="mod_autoindex">ReadmeName</directive>
      <em>など。</em>)。</dd>

      <dt>Limit</dt>

      <dd>
      ホストへのアクセス制御を行うためのディレクティブの使用を許可する (<directive
      module="mod_access">Allow</directive>, <directive
      module="mod_access">Deny</directive>, <directive
      module="mod_access">Order</directive>).</dd>

      <dt>Options</dt>

      <dd>
      特定のディレクトリにおける機能を指定するためのディレクティブの使用を許可する
      (<directive module="core">Options</directive> と
      <directive module="mod_include">XBitHack</directive>)。</dd>
    </dl>

    <p>例:</p>

    <example>
      AllowOverride AuthConfig Indexes
    </example>

    <p>上の例では <code>AuthConfig</code> と <code>Indexes</code> のどちらにも
    属さないディレクティブはすべて内部サーバエラーを引き起こします。</p>
</usage>

<seealso><directive module="core">AccessFileName</directive></seealso>
<seealso><a href="../configuring.html">設定ファイル</a></seealso>
<seealso><a href="../howto/htaccess.html">.htaccess ファイル</a></seealso>
</directivesynopsis>

<directivesynopsis>
<name>AuthName</name>
<description>HTTP 認証の認可領域 (訳注: realm)</description>
<syntax>AuthName <var>auth-domain</var></syntax>
<contextlist><context>directory</context><context>.htaccess</context>
</contextlist>
<override>AuthConfig</override>

<usage>
    <p>このディレクティブはディレクトリに対する認可領域 (訳注: realm)
    の名前を指定します。
    認可領域は、利用者がどのユーザ名とパスワードを送信すればよいのかを
    クライアントに教えるために利用します。
    <directive>AuthName</directive> は一つの引数をとり、
    スペースが含まれる場合には、
    引用符で括らなければなりません。
    このディレクティブは
    <directive module="core">AuthType</directive> ディレクティブや
    <directive module="core">Require</directive> ディレクティブと、
    <directive module="mod_auth">AuthUserFile</directive> や
    <directive module="mod_auth">AuthGroupFile</directive> などのディレクティブと
    一緒に利用する必要があります。</p>

   <p>例えば:</p>

   <example>
     AuthName "Top Secret"
   </example>

    <p>ここで <code>AuthName</code> に指定した文字列が、
    大部分のブラウザのパスワードダイアログに表示されます。</p>
</usage>
<seealso><a 
    href="../howto/auth.html">認証、承認、アクセス制御</a></seealso>
</directivesynopsis>

<directivesynopsis>
<name>AuthType</name>
<description>ユーザ認証の種類</description>
<syntax>AuthType Basic|Digest</syntax>
<contextlist><context>directory</context><context>.htaccess</context>
</contextlist>
<override>AuthConfig</override>

<usage>
    <p>このディレクティブは対象ディレクトリで利用するユーザー認証の種類を選びます。
    ただ、現在のところは <code>Basic</code> と <code>Digest</code> しか
    実装されていません。

    このディレクティブは <directive
    module="core">AuthName</directive>ディレクティブや
    <directive module="core">Require</directive> ディレクティブと、
    <directive module="mod_auth">AuthUserFile</directive> や <directive
    module="mod_auth">AuthGroupFile</directive> などのディレクティブと
    一緒に利用する必要があります。</p>
</usage>
<seealso><a href="../howto/auth.html">認証、承認、アクセス制御</a></seealso>
</directivesynopsis>

<directivesynopsis>
<name>CGIMapExtension</name>
<description>CGI スクリプトのインタープリタの位置を調べるための手法</description>
<syntax>CGIMapExtension <var>cgi-path</var> <var>.extension</var></syntax>
<default>None</default>
<contextlist><context>directory</context><context>.htaccess</context>
</contextlist>
<override>FileInfo</override>
<compatibility>NetWare のみ</compatibility>

<usage>
    <p>このディレクティブは Apache が CGI スクリプトを実行するための
    インタープリタを探す方法を制御します。
    例えば、<code>CGIMapExtension sys:\foo.nlm .foo</code> と設定すると
    <code>.foo</code> という拡張子のすべての CGI スクリプトは FOO インタープリタに
    渡されます。</p>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>ContentDigest</name>
<description><code>Content-MD5</code> HTTP 応答ヘッダの生成を有効にする</description> 
<syntax>ContentDigest On|Off</syntax>
<default>ContentDigest Off</default>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context>
</contextlist>
<override>Options</override>
<status>Experimental</status>

<usage>
    <p>このディレクティブは、RFC1864 及び RFC2068 において定義されている
    <code>Content-MD5</code> ヘッダーの生成を有効にします。</p>

    <p>MD5 は、任意長のデータの「メッセージダイジェスト」(「指紋」
    と表現されることもある) を計算するアルゴリズムで、
    データの変更があった場合には非常に高い信頼度でメッセージダイジェストに変更が
    反映されます。</p>

    <p><code>Content-MD5</code> ヘッダは、エンドツーエンドで
    エンティティボディーに含まれるメッセージの完全性チェック
    (Message Integrity Check - MIC)を提供します。
    このヘッダを調べることで、プロキシやクライアントは、
    途中経路におけるエンティティボディの予期せぬ変更などを
    検出することができます。ヘッダの例:</p>

    <example>
      Content-MD5: AuLb7Dp1rqtRtxz2m9kRpA==
    </example>

    <p>リクエスト毎にメッセージダイジェストを計算する (値はキャッシュされません)
    ことから、
    サーバパフォーマンスが低下することについて注意してください。</p>

    <p><code>Content-MD5</code >は、<module>core</module> 機能により処理された
    ドキュメントを送るときのみ有効であり、
    SSI ドキュメントや CGI スクリプトの出力、バイトレンジを指定した
    応答の場合にはこのヘッダは付与されません。
    </p>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>DefaultType</name>
<description>サーバがコンテントタイプを決定できないときに
送られる MIME コンテントタイプ</description>
<syntax>DefaultType <var>MIME-type</var></syntax>
<default>DefaultType text/plain</default>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context>
</contextlist>
<override>FileInfo</override>

<usage>
    <p>サーバは、MIME のタイプマップからは決定できない
    ドキュメントの送信を要求されることがあります。</p>

    <p>サーバは、ドキュメントのコンテントタイプをクライアントに通知する必要が
    ありますので、このようにタイプが未知の場合は
    <code>DefaultType</code> で指定されたタイプを利用します。
    例:</p>

    <example>
      DefaultType image/gif
    </example>

    <p>これは <code>.gif</code> という拡張子がファイル名に含まれていない
    多くの GIF 画像が含まれているディレクトリに適しているでしょう。</p>

    <p><directive module="core">ForceType</directive> ディレクティブと
    違って、このディレクティブはデフォルトの MIME タイプを提供するだけで
    あることに注意してください。ファイル名の拡張子を含め、
    メディアタイプを決定できる他の MIME タイプの定義があれば
    このデフォルトは上書きされます。</p>
</usage>
</directivesynopsis>

<directivesynopsis type="section">
<name>Directory</name>
<description>指定のファイルシステムのディレクトリとサブディレクトリとのみに
適用されるディレクティブを囲む</description>
<syntax>&lt;Directory <var>directory-path</var>&gt;
... &lt;/Directory&gt;</syntax>
<contextlist><context>server config</context><context>virtual host</context>
</contextlist>

<usage>
    <p>指定されたディレクトリとそのサブディレクトリにのみ
    ディレクティブを適用させるためには、
    <directive type="section">Directory</directive> と 
    <code>&lt;/Directory&gt;</code> を対として、ディレクティブ群を囲います。
    その中には、ディレクトリコンテキストで許可された全てのディレクティブを
    利用できます。
    <var>directive-path</var> は、フルパスもしくは Unix のシェル形式の
    ワイルドカードを指定します。
    <code>?</code> は任意の 1 文字、<code>*</code> は任意の文字列にマッチします。
    シェルにおける指定同様、文字の範囲を <code>[]</code> で指定できます。
    ワイルドカードは `/' 文字にはマッチしませんので、
    <code>/home/user/public_html</code> には
    <code>&lt;Directory /*/public_html&gt;</code> はマッチしませんが、
    <code>&lt;Directory /home/*/public_html&gt;</code> はマッチします。
    例:</p>

    <example>
      &lt;Directory /usr/local/httpd/htdocs&gt;<br />
      <indent>
        Options Indexes FollowSymLinks<br />
      </indent>
      &lt;/Directory&gt;
    </example>

<note>
<p><var>directory-path</var> 引数には注意してください: その引数は
Apache がファイルをアクセスするために使うファイルシステムのパスに
そのままマッチする必要があります。ある <code>&lt;Directory&gt;</code> に
適用されるディレクティブは、別のシンボリックリンクをたどったりして
同じディレクトリを違うパスでアクセスした場合には適用されません。</p>
</note>

    <p><code>~</code> という文字を
    付加することで拡張正規表現を利用することもできます。
    例えば:</p>

<example>
   &lt;Directory ~ "^/www/.*/[0-9]{3}"&gt;
</example>

    <p>といった指定の場合、<code>/www/</code> 以下にある数字
    3 文字のディレクトリにマッチします。</p>

    <p>もし複数の (正規表現以外の) <directive type="section"
    >Directory</directive>セクションが
    ドキュメントを含むディレクトリ (やその上位ディレクトリのどれか) とマッチしたならば、
    <a
    href="#accessfilename">.htaccess</a> ファイルのディレクティブも読み込みつつ、
    短いパスから順に適用されます。
    例えば、</p>

    <example>
      &lt;Directory /&gt;<br />
      <indent>
        AllowOverride None<br />
      </indent>
      &lt;/Directory&gt;<br />
      <br />
      &lt;Directory /home/&gt;<br />
      <indent>
        AllowOverride FileInfo<br />
      </indent>
      &lt;/Directory&gt;
    </example>

    <p>と設定し、ドキュメント <code>/home/web/dir/doc.html</code> への
    アクセスがあった場合には以下のように動作します:</p>

    <ul>
      <li><code>AllowOverride None</code> が適用される。
      (<code>.htaccess</code> ファイルは無効になる)</li>

      <li><code>AllowOverride FileInfo</code> が適用される
      (<code>/home</code> ディレクトリに対して)。</li>

      <li><code>/home/.htaccess</code>, <code>/home/web/.htaccess</code>,
      <code>/home/web/.htaccess</code> の順にそれらのファイル中の
       FileInfo ディレクティブが適用される。</li>
    </ul>

    <p>正規表現は、通常のセクションがすべて適用されるまで
    考慮されません。
    その後、全ての正規表現が設定ファイルに現れた順で試されます。
    例えば、以下のような場合に</p>

    <example>
      &lt;Directory ~ abc$&gt;<br />
      <indent>
        # ... directives here ...<br />
      </indent>
      &lt;/Directory&gt;
    </example>

    <p>正規表現のセクションはすべての通常の <directive
    type="section">Directory</directive> と
    <code>.htaccess</code> の適用が終わるまで考慮されません。
    その後で、正規表現は <code>/home/abc/public_html/abc</code> にマッチし、
    対応する <directive type="section">Directory</directive> が適用されます。</p>

    <p><strong>Apache のデフォルトでは <code>&lt;Directory /&gt;</code> へのアクセスは
    <code>Allow from All</code> になっていることに注意してください。
    これは、URL からマップされたどのファイルでも Apache は送るということです。
    これは以下のようにして変更することが推奨されています。</strong></p>

    <example>
      &lt;Directory /&gt;<br />
      <indent>
        Order Deny,Allow<br />
        Deny from All<br />
      </indent>
      &lt;/Directory&gt;
    </example>

    <p><strong>そしてアクセスを<em>可能にしたい</em>ディレクトリに対して
    個別に設定すればよいでしょう。
    このあたりについては、<a
    href="../misc/security_tips.html">セキュリティに関するコツ</a>を
    参照してください。</strong></p>

    <p>ディレクトリセクションは httpd.conf ファイル書きます。
    <directive type="section">Directory</directive>
    ディレクティブは入れ子にすることができず、
    <directive module="core" type="section">Limit</directive> や <directive
    module="core" type="section">LimitExcept</directive> セクションの中にも
    記述できません。</p>

</usage>
<seealso>リクエストを受けた際にこれらの異なるセクションが
    組み合わされる方法については <a href="../sections.html">
    &lt;Directory&gt;, &lt;Location&gt;, &lt;Files&gt; セクションの動作法</a></seealso>
</directivesynopsis>

<directivesynopsis type="section">
<name>DirectoryMatch</name>
<description>正規表現にマッチするファイルシステムのディレクトリと
サブディレクトリとのみに適用されるディレクティブを囲む</description>
<syntax>&lt;DirectoryMatch <var>regex</var>&gt;
... &lt;/DirectoryMatch&gt;</syntax>
<contextlist><context>server config</context><context>virtual host</context>
</contextlist>

<usage>
    <p><directive module="core" type="section">Directory</directive>
    ディレクティブと同様に、<directive type="section">DirectoryMatch</directive>
    と <code>&lt;/DirectoryMatch&gt;</code> は指定されたディレクトリと
    そのサブディレクトリにのみ適用されるディレクティブ群を囲います。
    しかし、このディレクティブは引数として正規表現をとります。例えば:</p>

    <example>
      &lt;DirectoryMatch "^/www/.*/[0-9]{3}"&gt;
    </example>

    <p>は /www/ 以下にある数字 3 文字のディレクトリにマッチします。</p>

</usage>
<seealso>通常の <directive type="section">Directory</directive> と正規表現の指定が
適用される順番については <directive type="section"
module="core">Directory</directive></seealso>
<seealso>リクエストを受けた際にこれらの異なるセクションが
    組み合わされる方法については <a href="../sections.html">
    &lt;Directory&gt;, &lt;Location&gt;, &lt;Files&gt; セクションの動作法</a></seealso>
</directivesynopsis>

<directivesynopsis>
<name>DocumentRoot</name>
<description>ウェブから見えるメインのドキュメントツリーになる
ディレクトリ</description>
<syntax>DocumentRoot <var>directory-path</var></syntax>
<default>DocumentRoot /usr/local/apache/htdocs</default>
<contextlist><context>server config</context><context>virtual host</context>
</contextlist>

<usage>
    <p>このディレクティブは、<code>httpd</code> がファイルを提供するディレクトリを設定します。
     <directive module="mod_alias">Alias</directive> のようなディレクティブにマッチしない場合には、
    ドキュメントの (訳注:ファイルシステム上の) パスを生成するために、
    リクエストされた URL のパス部分をドキュメントルートに付与します。
    例:</p>

    <example>
      DocumentRoot /usr/web
    </example>

    <p>この場合、
    <code>http://www.my.host.com/index.html</code> へのアクセスがあれば
    <code>/usr/web/index.html</code> が返されます。</p>

    <p><directive>DocumentRoot</directive> は最後のスラッシュ無しで
    指定する必要があります。</p>
</usage>
<seealso><a href="../urlmapping.html">URL をファイルシステムの位置に
マップする</a></seealso>
</directivesynopsis>

<directivesynopsis>
<name>EnableMMAP</name>
<description>配送中にファイルを読み込むためにメモリマッピングを
使うかどうか</description>
<syntax>EnableMMAP On|Off</syntax>
<default>EnableMMAP On</default>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context>
</contextlist>
<override>FileInfo</override>

<usage>
    <p>このディレクティブは配送中にファイルの内容を読み込む必要があるときに
    <code>httpd</code> がメモリマッピングを使うかどうかを制御します。デフォルトでは、
    例えば、<module>mod_include</module> を使って SSI ファイルを配送
    するときのように、ファイルの途中のデータをアクセスする必要があるときには
    Apache は OS がサポートしていればファイルをメモリにマップします。</p>

    <p>
    このメモリマップは性能の向上を持たらすことがあります。
    しかし、環境によっては運用上の問題を防ぐためにメモリマッピングを
    使用しないようにした方が良い場合もあります:</p>

    <ul>
    <li>マルチプロセッサシステムの中にはメモリマッピングをすると <code>httpd</code> の
    性能が落ちるものがあります。</li>
    <li>NFS マウントされた <directive module="core">DocumentRoot</directive>
    では、<code>httpd</code> がメモリマップしている間にファイルが削除されたり
    短くなったりしたときに起こるセグメンテーションフォールトのために
    <code>httpd</code> がクラッシュする可能性があります。</li>
    </ul>

    <p>これらの問題に当てはまるサーバの設定の場合は、以下のようにして
    ファイルの配送時のメモリマッピングを使用不可にしてください:</p>

    <example>
      EnableMMAP Off
    </example>

    <p>NFS マウントされたファイルには、問題のあるファイルにのみ明示的に
    この機能を使用不可にします:</p>

    <example>
      &lt;Directory "/path-to-nfs-files"&gt;
      <indent>
        EnableMMAP Off
      </indent>
      &lt;/Directory&gt;
    </example>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>EnableSendfile</name>
<description>ファイルのクライアントへの配送時にカーネルの sendfile サポートを
使うかどうか</description>
<syntax>EnableSendfile On|Off</syntax>
<default>EnableSendfile On</default>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context>
</contextlist>
<override>FileInfo</override>
<compatibility>バージョン 2.0.44 以降で使用可能</compatibility>

<usage>
    <p>このディレクティブはクライアンにファイルの内容を送るときに
    <code>httpd</code> がカーネルの
    sendfile サポートを使うかどうかを制御します。デフォルトでは、
    例えば静的なファイルの配送のように、リクエストの処理にファイルの
    途中のデータのアクセスを必要としないときには、Apache は OS が
    サポートしていればファイルを読み込むことなく sendfile を使って
    ファイルの内容を送ります。</p>

    <p>sendfile は read と send を別々に行なうことと、バッファの割り当てを
    回避します。しかし、プラットフォームやファイルシステムの中には
    運用上の問題を避けるためにこの機能を使用不可にした方が良い場合があります:</p>

    <ul>
    <li>プラットフォームの中にはビルドシステムが検知できなかった、壊れた
    sendfile のサポートが存在するものがあります。これは特に
    バイナリが別のマシンでビルドされ、壊れた sendfile のあるマシンに
    移動したときに起こります。</li>
    <li>Linux では、sendfile を用いると、
    IPv6 使用時に存在する特定ネットワークカードの TCP-checksum
    オフロードのバグを踏んでしまいます。</li>
    <li>ネットワークマウントされた <directive module="core">DocumentRoot</directive>
    (例えば NFS や SMB)
    では、カーネルは自身のキャッシュを使ってネットワークからのファイルを
    送ることができないことがあります。</li>
    </ul>

    <p>これらの問題に当てはまるサーバの設定の場合は、以下のようにして
    この機能を使用不可にしてください:</p>


    <example>
      EnableSendfile Off
    </example>

    <p>NFS や SMB マウントされたファイルには、問題のあるファイルにのみ明示的に
    この機能を使用不可にします:</p>

    <example>
      &lt;Directory "/path-to-nfs-files"&gt;
      <indent>
        EnableSendfile Off
      </indent>
      &lt;/Directory&gt;
    </example>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>ErrorDocument</name>
<description>エラーが発生したときにサーバがクライアントに送るもの</description>
<syntax>ErrorDocument <var>error-code document</var></syntax>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context>
</contextlist>
<override>FileInfo</override>
<compatibility>Apache 2.0 ではテキストをクウォートする構文が以前のバージョンから
変わっています。</compatibility>

<usage>
    <p>問題やエラーが発生したときの動作として、
    Apache には以下の四つのうち一つの動作を設定することができます。</p>

    <ol>
      <li>Apache 標準の簡単なエラーメッセージを表示</li>

      <li>自分で指定したメッセージを表示</li>

      <li>問題やエラーの処理をする為に、自サーバ内の
      <var>URL-path</var> へリダイレクト</li>

      <li>問題やエラーの処理をする為に、外部の <var>URL</var> へリダイレクト</li>
    </ol>

    <p>最初のものがデフォルトの動作で、2 番目から 4 番目は、
    <directive>ErrorDocument</directive>ディレクティブにより、
    HTTP のレスポンスコードと、メッセージか URL を指定することで設定します。
    Apache が問題もしくはエラーに関する追加情報を提供することがあります。</p>

    <p>URL の場合は、ローカルの URL の指定としてスラッシュで始まる (/) パスか、
    クライアントが解釈できるフル URL を指定します。<br />
    もしくは、ブラウザに表示されるメッセージを指定できます。
    例:</p>

    <example>
      ErrorDocument 500 http://foo.example.com/cgi-bin/tester<br />
      ErrorDocument 404 /cgi-bin/bad_urls.pl<br />
      ErrorDocument 401 /subscription_info.html<br />
      ErrorDocument 403 "Sorry can't allow you access today"
    </example>

    <p>加えて、特別な値 <code>default</code> を使って Apache に
    ハードコードされている簡単なメッセージを指定することができます。
    通常は必要ではありませんが、<code>default</code> を使うと
    既存の <directive>ErrorDocument</directive> ディレクティブの設定を
    継承するところで、Apache のハードコードされた簡単なメッセージに
    戻すことができます。</p>

    <example>
      ErrorDocument 404 /cgi-bin/bad_urls.pl<br /><br />
      &lt;Directory /web/docs&gt;<br />
      <indent>
        ErrorDocument 404 default<br />
      </indent>
      &lt;/Directory&gt;
    </example>

    <p>リモート URL (例えば、頭に <code>http</code> と付与した方法) を
    <directive>ErrorDocument</directive> に指定するとき、
    たとえ文書が同じサーバにあろうとも、ドキュメントがどこにあるかを通知するために、
    Apache はリダイレクトをクライアントに送出するということに、注意してください。
    これにはいろいろと関連して起こる問題があります。
    中でも最も重要なのは、クライアントは元々のエラーステータスコードを受け取らず、
    代わりにリダイレクトのステータスコードを受け取るということです。
    これにより、ステータスコードを使って URL が有効であるかどうかを決定しようとする
    ウェブロボットやその他クライアントを、混乱させるかもしれません。
    さらに、<code>ErrorDocument 401</code> にリモートの URL を指定すると、
    クライアントは 401 というステータスコードを受け取らないため、
    パスワードをユーザーに入力要求しなければならないことがわかりません。
    従って、<strong><code>ErrorDocument 401</code> というディレクティブを使う場合は、
    必ずローカルな文書を参照しなければなりません。</strong></p>

    <p>Microsoft Internet Explorer (MSIE) はデフォルトではサーバが生成したエラーメッセージが
    「小さすぎる」ときには無視をして自分自身の「やさしい」エラーメッセージで
    置換します。サイズのしきい値はエラーの種類によって異なりますが、
    一般的にはエラーの文書を 512 バイトよりも多きくすると、MSIE は
    サーバが生成したエラーを隠さずに表示します。詳しい情報は Microsoft
    Knowledge Base の記事 <a
    href="http://support.microsoft.com/default.aspx?scid=kb;en-us;Q294807">Q294807</a>
    にあります。</p>

    <p>2.0 より前のバージョンでは、対になっていない二重引用符を
    先頭に付けることによりメッセージであることを指定していました。</p>

</usage>

<seealso><a href="../custom-error.html">カスタマイズ可能な
エラー応答のドキュメンテーション</a></seealso>
</directivesynopsis>

<directivesynopsis>
<name>ErrorLog</name>
<description>サーバがエラーをログ収集する場所</description>    
<syntax> ErrorLog <var>file-path</var>|syslog[:<var>facility</var>]</syntax>
<default>ErrorLog logs/error_log (Unix) ErrorLog logs/error.log (Windows and OS/2)</default>
<contextlist><context>server config</context><context>virtual host</context>
</contextlist>

<usage>
    <p><directive>ErrorLog</directive> ディレクティブは、
    サーバに生じたさまざまなエラーを
    記録する為のファイルの名前を設定します。
    <var>file-path</var> が絶対パスでないときは、<directive
    module="core">ServerRoot</directive> からの相対パスとみなされます。</p>

    <example><title>例</title>
    ErrorLog /var/log/httpd/error_log
    </example>
    
    <p><var>file-path</var> がパイプ (|) から始まる場合は、
    エラーログを処理するために実行されるコマンドが
    指定されていると解釈されます。</p>

    <example><title>例</title>
    ErrorLog "|/usr/local/bin/httpd_errors"
    </example>

    <p>ファイル名の変わりに <code>syslog</code> と指定することによって、
    システムがサポートしていれば syslogd(8) を利用したロギングが有効になります。
    デフォルトでは、<code>local7</code> ファシリティとなりますが、
    <code>syslog:<var>facility</var></code> といった形で記述することにより、
    通常 syslog(1) のドキュメントで説明されているファシリティの一つを使うように
    することができます。</p>

    <example><title>例</title>
    ErrorLog syslog:user
    </example>

    <p>セキュリティ: 
    ログファイルを格納するディレクトリが、サーバを起動したユーザ以外の
    ユーザによって書き込める場合にセキュリティが破られる可能性があることに
    関する詳細は <a
    href="../misc/security_tips.html#serverroot">セキュリティに関するコツ</a> を
    参照してください。</p>
    <note type="warning"><title>注</title>
      <p>Unix 以外のプラットフォームでファイルのパスを入力するときは、
      プラットフォームがバックスラッシュの使用を許していたとしても、
      確実にスラッシュのみが使用されるように注意してください。一般的には、
      設定ファイル全般でスラッシュのみを使う方が良いでしょう。</p>
    </note>
</usage>
<seealso><directive module="core">LogLevel</directive></seealso>
<seealso><a href="../logs.html">Apache ログファイル</a></seealso>
</directivesynopsis>

<directivesynopsis>
<name>FileETag</name>
<description>ETag HTTP 応答ヘッダを作成するために使用される
ファイルの属性</description>
<syntax>FileETag <var>component</var> ...</syntax>
<default>FileETag INode MTime Size</default>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context>
</contextlist>
<override>FileInfo</override>

<usage>
    <p>
    <directive>FileETag</directive> ディレクティブは
    ドキュメントがファイルに基づいたものであるときに、
    <code>ETag</code> (エンティティタグ) 応答ヘッダフィールドを作成するときに使用する
    ファイルの属性を設定します。 (<code>ETag</code> の値はネットワークの帯域を節約するための
    キャッシュの管理で使われます。) Apache 1.3.22 以前では、<code>ETag</code> の値は
    <em>常に</em>ファイルの inode, サイズ、最終修正時刻 (mtime) から作成
    されていました。<directive>FileETag</directive> ディレクティブにより、これらのどれを使うかを
    選ぶことができます。認識されるキーワードは:
    </p>

    <dl>
     <dt><strong>INode</strong></dt>
     <dd>ファイルの inode 番号を計算に使います</dd>
     <dt><strong>MTime</strong></dt>
     <dd>ファイルの最終修正時刻を使います</dd>
     <dt><strong>Size</strong></dt>
     <dd>ファイルの中身のバイト数を使います</dd>
     <dt><strong>All</strong></dt>
     <dd>使用可能なすべてのフィールドを使います。
     これは <example>FileETag INode MTime Size</example> と等価です。</dd>
     <dt><strong>None</strong></dt>
     <dd>ドキュメントがファイルに基づいたものでも、<code>ETag</code> フィールドを
    応答に付加しません</dd>
    </dl>

    <p><code>INode</code>, <code>MTime</code>, <code>Size</code> キーワードには
    <code>+</code> や <code>-</code> を前に付けて
    指定することもできます。この場合は、より広い範囲から継承された
    デフォルトの設定に変更を加えるようになります。そのような接頭辞の
    無いキーワードを指定すると、即座に継承した設定を無効にします。</p>

    <p>あるディレクトリの設定に
    <code>FileETag&nbsp;INode&nbsp;MTime&nbsp;Size</code> があり、
    サブディレクトリの設定に <code>FileETag&nbsp;-INode</code> があるときは、
    そのサブディレクトリの設定は (設定が上書きされなければサブディレクトリの
    サブディレクトリにも継承されます) <code>FileETag&nbsp;MTime&nbsp;Size</code>
    と同じになります。</p>
</usage>
</directivesynopsis>

<directivesynopsis type="section">
<name>Files</name>
<description>マッチするファイル名に適用されるディレクティブを囲む</description>
<syntax>&lt;Files <var>filename</var>&gt; ... &lt;/Files&gt;</syntax>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context>
</contextlist>
<override>All</override>

<usage>
    <p><directive type="section">Files</directive> ディレクティブは、
    その中にあるディレクティブの適用範囲をファイル名で制限します。
    <directive module="core"
    type="section">Directory</directive> ディレクティブや <directive
    module="core" type="section">Location</directive> ディレクティブと
    同じような機能を持ちます。
    これは、<code>&lt;/Files&gt;</code> ディレクティブと対に
    なっていなければなりません。
    このセクション中のディレクティブは、ベース名 (ファイル名の最後の部分)
    が指定されたファイル名にマッチするすべてのオブジェクトに適用されます。
    <directive type="section">Files</directive> セクションは
    <directive type="section">Directory</directive> セクションと
    <code>.htaccess</code> が読み込まれた後、
    <directive type="section">Location</directive> セクションよりは先に
    設定ファイルに現れた順に適用されます。
    <directive type="section">Files</directive> は、
    <directive type="section">Directory</directive> セクション内に
    ネストさせることができ、
    ファイルシステムの一部にのみ限定して適用させることができます。</p>

    <p><var>filename</var> 引数は、ファイル名かワイルドカード文字列
    で、ワイルドカードでは <code>?</code> は一つの文字、<code>*</code> は任意の文字列にマッチします。
    <code>~</code> という文字を付加することで拡張正規表現を使うこともできます。
    例えば、</p>

    <example>
      &lt;Files ~ "\.(gif|jpe?g|png)$"&gt;
    </example>

    <p>とすることにより、一般的なインターネットの画像フォーマットにマッチします。
    ただし、
    <directive module="core" type="section">FilesMatch</directive> を使う方が
    推奨されています。</p>

    <p>ちなみに、<directive module="core" type="section"
    >Directory</directive> と <directive module="core" type="section"
    >Location</directive> セクションとは異なり、
    <directive type="section">Files</directive>
    は <code>.htaccess</code> ファイル内で利用することができます。
    これにより、ユーザがファイル毎にアクセスの制御を行なうことができるように
    なっています。</p>

</usage>
<seealso>リクエストを受けた際にこれらの異なるセクションが
    組み合わされる方法については <a href="../sections.html">
    &lt;Directory&gt;, &lt;Location&gt;, &lt;Files&gt; セクションの動作法</a></seealso>
</directivesynopsis>

<directivesynopsis type="section">
<name>FilesMatch</name>
<description>正規表現にマッチするファイル名に適用される
ディレクティブを囲む</description>
<syntax>&lt;FilesMatch <var>regex</var>&gt; ... &lt;/FilesMatch&gt;</syntax>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context>
</contextlist>
<override>All</override>

<usage>
    <p><directive type="section">FilesMatch</directive> ディレクティブは、
    <directive module="core" type="section">Files</directive>
    ディレクティブ同様にその中にあるディレクティブの適用範囲をファイル名で制限します。ただし、
    このディレクティブには正規表現を指定します。
    例えば:</p>

    <example>
      &lt;FilesMatch "\.(gif|jpe?g|png)$"&gt;
    </example>

    <p>は一般的なインターネットの画像形式にマッチします。</p>
</usage>

<seealso>リクエストを受けた際にこれらの異なるセクションが
    組み合わされる方法については <a href="../sections.html">
    &lt;Directory&gt;, &lt;Location&gt;, &lt;Files&gt; セクションの動作法</a></seealso>
</directivesynopsis>

<directivesynopsis>
<name>ForceType</name>
<description>すべてのマッチするファイルが指定の MIME コンテントタイプで
送られるようにする</description>
<syntax>ForceType <var>MIME-type</var>|None</syntax>
<contextlist><context>directory</context><context>.htaccess</context>
</contextlist>
<override>FileInfo</override>
<compatibility>Apache 2.0 で core に移動</compatibility>

<usage>
    <p><code>.htaccess</code> や <directive type="section" module="core"
    >Directory</directive> セクション、
    <directive type="section" module="core">Location</directive> セクション、
    <directive type="section" module="core">Files</directive> セクションに
    書かれた場合、このディレクティブはそこにあるすべてのファイルが
    <var>MIME-type</var>
    で指定されたコンテントタイプとして扱われるようにします。たとえば、
    GIF ファイルばかりのディレクトリがあって、すべてのファイルを <code>.gif</code>
    で終わらせたくはないときに、以下のものを使用します:</p>

    <example>
      ForceType image/gif
    </example>

    <p><directive module="core">DefaultType</directive> と違って
    このディレクティブはメディアタイプを決めることができるかもしれない
    ファイルの拡張子も含め、すべての MIME タイプの関連付けを
    上書きすることに注意してください。</p>

    <p><code>None</code> という値を使うことで <directive>ForceType</directive> の
    設定を無効にできます:</p>

    <example>
      # force all files to be image/gif:<br />
      &lt;Location /images&gt;<br />
        <indent>
          ForceType image/gif<br />
        </indent>
      &lt;/Location&gt;<br />
      <br />
      # but normal mime-type associations here:<br />
      &lt;Location /images/mixed&gt;<br />
      <indent>
        ForceType None<br />
      </indent>
      &lt;/Location&gt;
    </example>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>HostnameLookups</name>
<description>クライアントの IP アドレスの DNS ルックアップを
有効にする</description>
<syntax>HostnameLookups On|Off|Double</syntax>
<default>HostnameLookups Off</default>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context></contextlist>

<usage>
    <p>このディレクティブは、ホスト名をログ収集できるように
    DNS ルックアップを有効にします
    (さらに、CGI/SSI に <code>REMOTE_HOST</code> 変数として渡します)。
    <code>Double</code>を指定した場合、2 重の逆引きを行ないます。
    つまり、逆引きの後に、その結果に対して正引きを行ないます。正引きの
    結果の IP アドレスの中にオリジナルのアドレスと一致するものがなければ
    なりません。("tcpwrappers" の用語では PARANOID と呼ばれています。)</p>

    <p><module>mod_access</module> でホスト名によるアクセス
    制御を行なう場合には、
    設定の如何によらず 2 重の逆引きが実行されます。
    これは、セキュリティを保つために必要です。
    <code>HostnameLookups Double</code> を設定しない限り、
    他の部分はこの 2 重逆引きの結果を使うことはできません。
    例えば、<code>HostnameLookups On</code> と設定してある状態で、
    ホスト名によるアクセス制限を行なったオブジェクトへの
    リクエストを受けたとすると、2 重の逆引きが成功するか否かによらず、
    <code>REMOTE_HOST</code> には通常の逆引き結果が渡されます。</p>

    <p>ディレクティブのデフォルトは
    本当に逆引きを必要としているわけではないサイトの
    ネットワークトラフィックを低減させるために、<code>Off</code> になっています。
    ルックアップによる余計な遅延がなくなるため、
    エンドユーザにとっても良いでしょう。
    DNS のルックアップには、かなりの時間が必要となる場合が多く、
    負荷の高いサイトではこのディレクティブは <code>Off</code> にすべきです。
    なお、<var>/support</var> ディレクトリに含まれ、デフォルトでは
    インストールディレクトリの <code>bin</code> サブディレクトリに
    インストールされる <a
    href="../programs/logresolve.html">logresolve</a> ユーティリティにより、
    Apache の動作とは別に、ログに残されている IP アドレスからホスト名を
    ルックアップすることが可能です。</p>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>IdentityCheck</name>
<description>リモートユーザの RFC1413 によるアイデンティティのロギングを
有効にする</description>
<syntax>IdentityCheck On|Off</syntax>
<default>IdentityCheck Off</default>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context></contextlist>
<usage>
    <p>このディレクティブは、クライアントマシン上で
    identd やそれに類似したデーモンが動作しているときに、
    それぞれの接続に対して RFC 1413 に準処したリモートユーザの
    名前のロギングを行なうようにします。
    この情報は、アクセスログに収集されます。</p>

    <p>ここで得られた情報は簡単なユーザ追跡に使う以外は、
    まったく信頼するべきではありません。</p>

    <p>すべてのリクエストに対してルックアップが行なわれますので、
    深刻な遅延の問題を起こすかもしれないことに注意してください。
    (訳注: 例えばクライアント側に) ファイアウォールがあると、
    ルックアップが失敗し、各リクエストに 30 秒の遅延が加わることに
    なる可能性があります。
    従って、一般的にはインターネットからアクセス可能なパブリックなサーバで
    有益なものではありません。</p>
</usage>
</directivesynopsis>

<directivesynopsis type="section">
<name>IfDefine</name>
<description>起動時にテストが真であるときのみに処理されるディレクティブを
囲む</description>
<syntax>&lt;IfDefine [!]<var>parameter-name</var>&gt; ...
    &lt;/IfDefine&gt;</syntax>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context>
</contextlist>
<override>All</override>

<usage>
    <p><code>&lt;IfDefine <var>test</var>&gt;...&lt;/IfDefine&gt;</code>
    セクションは、
    ディレクティブを条件付きで指定するために利用します。
    <directive type="section">IfDefine</directive> セクションに
    含まれるディレクティブは、<var>test</var>が
    定義されているときのみ処理されます。
    もし <var>test</var> が定義されていなければ、
    開始と終了の指定の間のディレクティブは無視されます。</p>

    <p><directive type="section">IfDefine</directive> セクションディレクティブに
    指定する <var>test</var> は、
    次の二つの形式のうちの一つをとります:</p>

    <ul>
      <li><var>parameter-name</var></li>

      <li><code>!</code><var>parameter-name</var></li>
    </ul>

    <p>前者の場合には、<var>parameter-name</var> と名付けられたパラメータが
    定義されていれば開始と終了の間のディレクティブが処理されます。
    後者の場合は逆で、<em>parameter-name</em> が指定されて<strong>いない</strong>
    場合に処理されます。</p>

    <p><var>parameter-name</var> 引数は、サーバを起動する際に
    <code>httpd</code> のコマンドラインに
    <code>-D<var>parameter-</var></code> という形で指定すると定義されます。 </p>

    <p><directive type="section">IfDefine</directive> セクションは
    入れ子にすることができ、複数のパラメータによるテストをするために使用できます。
    例:</p>

    <example>
      httpd -DReverseProxy ...<br />
      <br />
      # httpd.conf<br />
      &lt;IfDefine ReverseProxy&gt;<br />
      <indent>
        LoadModule rewrite_module modules/mod_rewrite.so<br />
        LoadModule proxy_module   modules/libproxy.so<br />
      </indent>
      &lt;/IfDefine&gt;
    </example>
</usage>
</directivesynopsis>

<directivesynopsis type="section">
<name>IfModule</name>
<description>モジュールの存在するかしないかに応じて処理される
ディレクティブを囲む</description>
<syntax>&lt;IfModule [!]<var>module-name</var>&gt; ...
    &lt;/IfModule&gt;</syntax>     
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context>
</contextlist>
<override>All</override>

<usage>
    <p><code>&lt;IfModule <var>test</var>&gt;...&lt;/IfModule&gt;</code>
    セクションは、モジュールが存在するときに処理されるディレクティブを
    指定するために利用します。
    <directive type="section">IfModule</directive> セクションに
    含まれるディレクティブは、<var>test</var>
    で指定するモジュールが組み込まれているときのみ処理されます。
    もし <var>test</var> が組み込まれていなければ、開始と終了の間のディレクティブ
    は無視されます。</p>

    <p><directive type="section">IfModule</directive> セクションディレクティブに
    指定する <var>test</var> は、
    次の二つの形式のうちの一つをとります。</p>

    <ul>
      <li><var>module name</var></li>

      <li>!<var>module name</var></li>
    </ul>

    <p>前者の場合は、<var>module name</var> と名付けられたモジュールが
    Apache に組み込まれていれば
    (コンパイル済みのものと、<directive
    module="mod_so">LoadModule</directive> を利用して
    動的に読み込んだものの両方)、
    開始と終了の間のディレクティブが処理されます。
    後者の場合は逆で、<var>module name</var> が組み込まれて<strong>いない</strong>
    場合に処理されます。</p>

    <p><var>module name</var> 引数は、
    コンパイルをした時のモジュールのファイル名です。
    例えば、
    <code>mod_rewrite.c</code> です。
    モジュールが複数のソースファイルから構成されている場合は、文字列
    <code>STANDARD20_MODULE_STUFF</code> があるファイルの名前を
    使ってください。</p>

    <p><directive type="section">IfModule</directive> セクションは
    入れ子にすることが可能であり、
    複数のモジュールのテストを行なうために使用できます。</p>

    <note>特定のモジュールの存在に関わらず動作する
    設定ファイルの原本が必要なときにのみこのセクションを使用してください。
    通常の動作では、ディレクティブを
    <directive type="section">IfModule</directive> セクションの中に
    入れる必要はありません。</note>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>Include</name>
<description>サーバ設定ファイル中から他の設定ファイルを取り込む</description>
<syntax>Include <var>file-path</var>|<var>directory-path</var></syntax>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context>
</contextlist>
<compatibility>ワイルドカードによるマッチは 2.0.41 以降で使用可能</compatibility>

<usage>
    <p>このディレクティブにより、サーバの設定ファイルから
    他の設定ファイルをインクルードすることができます。</p>

    <p>複数のファイルをアルファベット順に一度に読み込むために、
    シェル形式 (<code>fnmatch</code>) のワイルドカード文字を使うことができます。
    さらに、<directive>Include</directive> にディレクトリを指定した場合は、
    ディレクトリとそのサブディレクトリ内の全てのファイルを
    アルファベット順に読み込んで、設定ファイルとして処理します。
    しかし、ディレクトリ全体を読み込むのはお勧めできません。
    ふとしたことから <code>httpd</code> が読み込みに失敗するような
    一時ファイルをディレクトリに残してしまうようなことがよくあるからです。</p>

    <p>指定するファイルパスは絶対パスか、
    <directive module="core">ServerRoot</directive> ディレクトリからの
    相対パスか、のどちらかです。</p>

    <p>例:</p>

    <example>
      Include /usr/local/apache2/conf/ssl.conf<br />
      Include /usr/local/apache2/conf/vhosts/*.conf
    </example>

     <p><directive module="core">ServerRoot</directive> からの相対パスの場合は:</p>

    <example>
      Include conf/ssl.conf<br />
      Include conf/vhosts/*.conf
    </example>

    <p><code>apachectl configtest</code> を実行すると、設定をチェックしている時に
    読み込まれたファイルのリストが表示されます:</p>

    <example>
      root@host# apachectl configtest<br />
      Processing config file: /usr/local/apache2/conf/ssl.conf<br />
      Processing config file: /usr/local/apache2/conf/vhosts/vhost1.conf<br />
      Processing config file: /usr/local/apache2/conf/vhosts/vhost2.conf<br />
      Syntax OK
    </example>
</usage>

<seealso><a href="../programs/apachectl.html">apachectl</a></seealso>
</directivesynopsis>

<directivesynopsis>
<name>KeepAlive</name>
<description>HTTP の持続的な接続を有効にする</description>
<syntax>KeepAlive On|Off</syntax>
<default>KeepAlive On</default>
<contextlist><context>server config</context><context>virtual host</context>
</contextlist>

<usage>
    <p>HTTP/1.0 の Keep-Alive 拡張と HTTP/1.1 の持続的接続の機能は、
    複数のリクエストが同じ TCP の接続で送られる、長時間持続する
    HTTP セッションを提供します。たくさんの画像が
    含まれる HTML ドキュメントでは場合によっては遅延時間が 50% 短縮される結果も
    でています。Keep-Alive 接続を有効にするには
    <code>KeepAlive On</code> と設定します。</p>

    <p>HTTP/1.0 に対応したクライアントの際には、
    クライアントより特に要求があった場合のみ Keep-Alive 接続となります。
    さらに、HTTP/1.0 クライアントでは、コンテンツの容量が先に
    (訳注: 要求に対して応答を返す前に) わかる場合のみ Keep-Alive
    接続を利用できます。
    これは、CGI の出力や SSI のページ、
    サーバが生成したディレクトリのリストのような動的コンテンツを
    HTTP/1.0 クライアントに送る場合には Keep-Alive 接続を使えないことを意味します。
    HTTP/1.1 に対応したクライアントの際には、
    特に指定されない限りはデフォルトとして持続的な接続が行なわれます。
    クライアントが要求すれば、コンテンツの容量を判別できないものを
    持続的な接続を通して送るために、チャンクエンコーディングが用いられます。</p>
</usage>

<seealso><directive module="core">MaxKeepAliveRequests</directive></seealso>
</directivesynopsis>

<directivesynopsis>
<name>KeepAliveTimeout</name>
<description>持続的な接続で次のリクエストが来るまでサーバが待つ時間</description>
<syntax>KeepAliveTimeout <var>seconds</var></syntax>
<default>KeepAliveTimeout 15</default>
<contextlist><context>server config</context><context>virtual host</context>
</contextlist>

<usage>
    <p>接続を閉じる前に、Apache が次のリクエストを何秒待つかを指定します。
    リクエストを受け付けた後は、<directive
    module="core">Timeout</directive> ディレクティブによって
    指定されたタイムアウト値が使われます。</p>

    <p><directive>KeepAliveTimeout</directive> を大きな値に設定すると、
    負荷の高いサーバにおいてはパフォーマンスの問題を引き起こす場合があります。
    タイムアウトが長ければ長いほど、より多くのサーバプロセスが
    活発でないクライアントからの接続の終了を待ち続けることになります。</p>
</usage>
</directivesynopsis>

<directivesynopsis type="section">
<name>Limit</name>
<description>囲いの中にあるアクセス制御の適用を特定の HTTP メソッドのみに
制限する</description>    
<syntax>&lt;Limit <var>method</var> [<var>method</var>] ... &gt; ...
    &lt;/Limit&gt;</syntax>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context>
</contextlist>
<override>All</override>

<usage>
    <p>アクセス制御は、通常<strong>全ての</strong>アクセスメソッドに対して
    影響し、普通はこれが望ましい挙動です。
    <strong>そうしたことから、大部分の場合にはアクセス制御に関わるディレクティブを
    <directive type="section">Limit</directive> セクション内に
    書くべきではありません。 </strong></p>

    <p><directive type="section">Limit</directive> ディレクティブの
    目的は、アクセス制御の範囲を
    指定された HTTP メソッドに限定するためです。
    それ以外のメソッドは、<directive type="section">Limit</directive> で囲われたアクセス制御の
    <strong>影響を受けません</strong>。
    以下の例は、<code>POST</code>, <code>PUT</code>, <code>DELETE</code> のメソッドに対してのみアクセスの制御を行ない、
    それ以外のメソッドについては制限しません:</p>

    <example>
      &lt;Limit POST PUT DELETE&gt;<br />
      <indent>
        Require valid-user<br />
      </indent>
      &lt;/Limit&gt;
    </example>

    <p>メソッド名には以下の中から一つ以上を列挙することができます:
    <code>GET</code>,
    <code>POST</code>, <code>PUT</code>, <code>DELETE</code>,
    <code>CONNECT</code>, <code>OPTIONS</code>,
    <code>PATCH</code>, <code>PROPFIND</code>, <code>PROPPATCH</code>,
    <code>MKCOL</code>, <code>COPY</code>, <code>MOVE</code>,
    <code>LOCK</code>, <code>UNLOCK</code>. <strong>メソッド名は
    大文字小文字を区別します。</strong> <code>GET</code> を指定した場合には
    <code>HEAD</code> リクエストにも制限がかかります。<code>TRACE</code>
    メソッドに制限をかけることはできません。</p>

    <note type="warning">アクセス制御が目的の場合は
    <directive type="section" module="core">Limit</directive> 
    セクションの代わりに <directive type="section" 
    module="core">LimitExcept</directive> セクションを使用した方が良いでしょう。
    <directive type="section" module="core">LimitExcept</directive>
    セクションでは不特定のメソッドに対しても防御できるからです。</note>

</usage>
</directivesynopsis>

<directivesynopsis type="section">
<name>LimitExcept</name>
<description>指定されたもの以外の HTTP メソッドにアクセス制御を
制限する</description>
<syntax>&lt;LimitExcept <var>method</var> [<var>method</var>] ... &gt; ...
    &lt;/LimitExcept&gt;</syntax>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context>
</contextlist>
<override>All</override>

<usage>
    <p><directive type="section">LimitExcept</directive> と
    <code>&lt;/LimitExcept&gt;</code> は、引数に
    <strong>含まれていない</strong>
    HTTP のアクセスメソッドに適用するためのアクセス制御
    ディレクティブを括るために利用します。
    つまり、<directive type="section" module="core"
    >Limit</directive> セクションの反対の動作をし、
    標準のメソッドと標準外や未認識のメソッドの場合の両方を設定できます。
    <directive type="section" module="core">Limit</directive> のドキュメントも
    併せて参照してください。</p>

    <p>例:</p>

    <example>
      &lt;LimitExcept POST GET&gt;<br />
      <indent>
        Require valid-user<br />
      </indent>
      &lt;/LimitExcept&gt;
    </example>

</usage>
</directivesynopsis>

<directivesynopsis>
<name>LimitInternalRecursion</name>
<description>内部リダイレクトと入れ子になったサブリクエストの最大数を決定する</description>
<syntax>LimitInternalRecursion <var>number</var> [<var>number</var>]</syntax>
<default>LimitInternalRecursion 10</default>
<contextlist><context>server config</context><context>virtual host</context>
</contextlist>
<compatibility>Apache 2.0.47 以降で使用可能</compatibility>

<usage>
    <p>内部リダイレクトは例えば <directive>Action</directive> ディレクティブを
    使っているときに起こります。<directive>Action</directive> ディレクティブは
    元々のリクエストを CGI スクリプトに内部リダイレクトを行ないます。
    サブリクエストはいくつかの URI に対して、リクエストされたときに
    何が起こるかを調べるための Apache の機構です。例えば、<module>mod_dir</module>
    は <directive module="mod_dir">DirectoryIndex</directive> ディレクティブ
    がリストするファイルを調べるためにサブリクエストを使います。</p>

    <p><directive>LimitInternalRecursion</directive> は内部リダイレクトや
    サブリクエストが無限ループに陥ったときのサーバクラッシュを防ぎます。
    普通、そのようなループは設定に失敗したときに発生します。</p>

    <p>このディレクティブは、リクエスト毎に評価される、二つの違う限界値を
    設定します。最初の <var>number</var> は、起こり得る
    内部リクエストの最大値を設定します。二つめの <var>number</var> は
    サブリクエストが入れ子にできる深さを設定します。<var>number</var> を
    一つだけ指定したときは、両方の限界値にその値が設定されます。</p>

    <example><title>例</title>
      LimitInternalRecursion 5
    </example>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>LimitRequestBody</name>
<description>クライアントから送られる HTTP リクエストのボディの
総量を制限する</description>
<syntax>LimitRequestBody <var>bytes</var></syntax>
<default>LimitRequestBody 0</default>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context>
</contextlist>
<override>All</override>

<usage>
    <p>このディレクティブは、リクエストボディに許されるバイト数、<var>bytes</var>
    を 0 (無制限を意味します) から 2147483647 (2GB) までの数値で指定します。</p>

    <p><directive>LimitRequestBody</directive> ディレクティブは、
    ディレクティブが書かれたコンテキスト
    (サーバ全体、ディレクトリ、ファイル、ロケーション) 内で
    許容する  HTTP リクエストメッセージボディのサイズに制限をかけることができます。
    クライアントのリクエストがその制限値を越えていれば、
    サーバはリクエストを処理せずにエラーを返します。
    普通のリクエストメッセージボディのサイズは、リソースの種類や
    許可されているメソッドによって大きく変わります。
    CGI スクリプトは、よく情報を受信するために
    メッセージボディを使います。
    <code>PUT</code> メソッドの実装は、このディレクティブの値として
    少なくともあるリソースに対してサーバが受け付けようとする
    表現の大きさほどの値を必要とします。</p>

    <p>このディレクティブは、
    管理者にクライアントからの異常なリクエストを制御できるようにし、
    何らかの形のサービス拒否攻撃 (訳注:DoS) を避けるのに有効です。</p>

    <p>ある場所へのファイルアップロードを許可する場合に、
    アップロードできるファイルのサイズを 100K に制限したければ、
    以下のように指定します:</p>

    <example>
      LimitRequestBody 102400
    </example>

</usage>
</directivesynopsis>

<directivesynopsis>
<name>LimitRequestFields</name>
<description>クライアントからの HTTP リクエストのヘッダフィールドの数を
制限する</description>
<syntax>LimitRequestFields <var>number</var></syntax>
<default>LimitRequestFields 100</default>
<contextlist><context>server config</context></contextlist>

<usage>
    <p><var>number</var> には、0 (無制限を意味します) から 32767
    までの整数を指定します。
    デフォルト値は、定数 <code>DEFAULT_LIMIT_REQUEST_FIELDS</code>
    によりコンパイル時に定義されます (配布時には 100 と指定されています)。</p>

    <p>LimitRequestBody ディレクティブは、
    サーバ管理者が HTTP リクエスト中において許可するリクエストヘッダフィールド数を
    指定します。
    サーバはこの値には通常のクライアントからのリクエストに含まれるであろう
    フィールドの数より大きな値が必要とします。
    クライアントにより使われた要求ヘッダーフィールドの数が
    20 を超えることはほとんどありませんが、
    これは種々のクライアントの実装よって変わり、
    詳細なコンテントネゴシエーションをするためのブラウザの設定までにも
    影響されることがあります。
    オプションの HTTP 拡張はリクエストヘッダフィールドを使って現される場合が
    多くあります。</p>

    <p>このディレクティブは、
    管理者にクライアントからの異常なリクエストを制御できるようにし、
    何らかの形のサービス拒否攻撃 (訳注:DoS) を避けるのに有効です。
    リクエストのフィールドが多過ぎることを意味するエラー応答が
    普通のクライアントに返されるような時はこの値を増やしてください。</p>

    <p>例:</p>

    <example>
      LimitRequestFields 50
    </example>

</usage>
</directivesynopsis>

<directivesynopsis>
<name>LimitRequestFieldSize</name>
<description>クライアントからの HTTP リクエストのヘッダの
サイズを制限する</description>
<syntax>LimitRequestFieldsize <var>bytes</var></syntax>
<default>LimitRequestFieldsize 8190</default>
<contextlist><context>server config</context></contextlist>

<usage>
    <p>このディレクティブは、HTTP リクエストヘッダ内に含めることのできる
    バイト数、<var>bytes</var> を
    0 からコンパイル時に定義される定数
    <code>DEFAULT_LIMIT_REQUEST_FIELDSIZE</code> (配布時には 8192 と指定)
    で指定された値までの数字で指定します。</p>

    <p><directive>LimitRequestFieldSize</directive> ディレクティブは、
    サーバのコンパイル時に指定したインプットバッファ容量以下に
    HTTP リクエストヘッダの許容されるサイズを制限することができます。
    サーバは、このディレクティブの値として、
    通常のクライアントリクエストから送られた個々のヘッダフィールドに
    十分足る大きさを必要とします。
    普通のリクエストヘッダのサイズは、個々のクライアントにより大きく変わり、
    詳細なコンテントネゴシエーションをするためのブラウザの設定までにも
    影響されることがあります。</p>

    <p>このディレクティブは、
    管理者にクライアントからの異常なリクエストを制御できるようにし、
    何らかの形のサービス拒否攻撃 (訳注:DoS) を避けるのに有効です。</p>

    <p>例:</p>

    <example>
      LimitRequestFieldSize 4094
    </example>

    <note>通常はデフォルトから変更する必要はありません。</note>

</usage>
</directivesynopsis>

<directivesynopsis>
<name>LimitRequestLine</name>
<description>クライアントからの HTTP リクエスト行のサイズを制限する</description>
<syntax>LimitRequestLine <var>bytes</var></syntax>
<default>LimitRequestLine 8190</default>
<contextlist><context>server config</context></contextlist>

<usage>
    <p>このディレクティブは、HTTP リクエスト行内で許容されるバイト数
    <var>bytes</var> を 0 からコンパイル時の定数
    <code>DEFAULT_LIMIT_REQUEST_LINE</code> (配布時には 8190 と指定)
    で指定された値までの数字で指定します。</p>

    <p><directive>LimitRequestLine</directive> ディレクティブにより、サーバ管理者は
    サーバのコンパイル時に指定したインプットバッファ容量以下に
    クライアントからの HTTP リクエスト行のサイズの制限を行なうことができます。 
    リクエスト行は、HTTPメソッド、URI、プロトコルバージョンから成っており、
    <directive>LimitRequestLine</directive> はサーバへのリクエストに対して
    許容するリクエスト URI の長さを制限することになります。
    サーバは、<code>GET</code> リクエストのクエリ部分も含めて、リソースの名前が入るに足る
    大きさを必要とします。</p>

    <p>このディレクティブは、
    管理者にクライアントからの異常なリクエストを制御できるようにし、
    何らかの形のサービス拒否攻撃 (訳注:DoS) を避けるのに有効です。</p>

    <p>例:</p>

    <example>
      LimitRequestLine 4094
    </example>

    <note>通常はデフォルトから変更する必要はありません。</note>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>LimitXMLRequestBody</name>
<description>XML 形式のリクエストのボディのサイズを制限する</description>
<syntax>LimitXMLRequestBody <var>bytes</var></syntax>
<default>LimitXMLRequestBody 1000000</default>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context></contextlist>
<override>All</override>

<usage>
    <p>XML 形式のリクエストのボディの最大値を (バイト単位で) 制限します。
    値に <code>0</code> を指定するとチェックを無効にします。</p>

    <p>例:</p>

    <example>
    LimitXMLRequestBody 0
    </example>

</usage>
</directivesynopsis>

<directivesynopsis type="section">
<name>Location</name>
<description>囲んだディレクティブをマッチする URL のみに適用</description>
<syntax>&lt;Location
    <var>URL-path</var>|<var>URL</var>&gt; ... &lt;/Location&gt;</syntax>
<contextlist><context>server config</context><context>virtual host</context>
</contextlist>

<usage>
    <p><directive type="section">Location</directive> ディレクティブは、
    URL により中に書かれたディレクティブの適用範囲を制限します。
    <directive type="section" module="core">Directory</directive>
    ディレクティブと似ていて、
    <code>&lt;/Location&gt;</code> ディレクティブで終了する
    サブセクションを開始します。
    <directive type="section">Location</directive> セクションは、
    <directive type="section" module="core">Directory</directive> セクションと
    <code>.htaccess</code> の読み込みの後、
    <directive type="section" module="core">Files</directive> セクションを
    適用した後に、設定ファイルに現れた順に処理されます。</p>

    <p><directive type="section">Location</directive> セクションは
    完全にファイルシステムと関連せずに動作します。このことから導かれる
    結果にはいつくか注意する点があります。最も重要なものは、
    ファイルシステムの位置へのアクセス制御に <directive
    type="section">Location</directive> ディレクティブを使うべきではない
    ということです。複数の URL がファイルシステムの同じ位置にマップされる
    可能がありますので、そのようなアクセス制御は回避されてしまう可能性が
    あります。</p>

    <note><title>いつ <directive 
    type="section">Location</directive> を使うか</title>

    <p><directive type="section">Location</directive> ディレクティブは
    ファイルシステム外のコンテンツにディレクティブを適用するときに
    使用してください。ファイルシステムに存在するコンテンツに対しては、
    <directive
    type="section" module="core">Directory</directive> と <directive
    type="section" module="core">Files</directive> を使ってください。
    例外は、<code>&lt;Location /&gt;</code> で、これはサーバ全体に対して
    設定を適用する簡単な方法です。</p>
    </note>

    <p>全ての (プロキシ以外の) リクエストに対し、
    URL は <code>/path/</code> という、
    接頭辞 <code>http://servername</code> を含まない形でマッチします。
    プロキシリクエストの場合には、<code>scheme://servername/path</code>
    という接頭辞を含む形でマッチし、接頭辞を含めて指定する必要があります。</p>

    <p>URL にはワイルドカードを利用することができます。
    <code>?</code> は任意の一文字、<code>*</code> は任意の文字列にマッチします。 </p>

    <p><code>~</code> という文字を追加することで、拡張正規表現を
    利用することもできます。
    例えば:</p>

    <example>
      &lt;Location ~ "/(extra|special)/data"&gt;
    </example>

    <p>は URL に <code>/extra/data</code> か <code>/special/data</code> という文字列が
    含まれている場合にマッチします。
   <directive type="section" module="core"
    >LocationMatch</directive> ディレクティブは
    <directive type="section">Location</directive> の正規表現
    版とまったく同じ動作をします。</p>

    <p><directive type="section">Location</directive> 機能は、<directive
    module="core">SetHandler</directive> ディレクティブと
    組合わせて利用すると特に便利です。
    例えば、<code>foo.com</code> のブラウザからのみステータスの参照を有効にしたければ、
    次のようにすれば良いでしょう。</p>

    <example>
      &lt;Location /status&gt;<br />
      <indent>
        SetHandler server-status<br />
        Order Deny,Allow<br />
        Deny from all<br />
        Allow from .foo.com<br />
      </indent>
      &lt;/Location&gt;
    </example>

<note><title>/ (スラッシュ) に関する注</title>
    <p>スラッシュ文字は、URL 内に現れる場所に応じて変化する
    特別な意味を持っています。
    ファイルシステムにおいて利用する場合には複数のスラッシュでも一つの
    スラッシュとして扱われることが多いですが、
    (<em>すなわち</em>、<code>/home///foo</code> は
    <code>/home/foo</code> と同じいったように)
    URL においては必ずしもそうなるわけではありません。
    <directive type="section" module="core">LocationMatch</directive>
    ディレクティブや正規表現を利用した
    <directive type="section">Location</directive> ディレクティブで、
    複数のスラッシュにマッチさせたいときには、、明示的に記述する
    必要があります。</p>

    <p>例えば、<code>&lt;LocationMatch ^/abc&gt;</code> は、
    <code>/abc</code> というリクエスト URL にマッチしますが、
    <code>//abc</code> というリクエスト URL にはマッチしません。
    (正規表現でない) <directive type="section">Location</directive>
    ディレクティブは、
    proxy リクエストに対して利用する際には同様の振る舞いをしますが、
    (正規表現でない) <directive type="section">Location</directive> を proxy
    でないリクエストに対して利用する際には、
    一つのスラッシュで複数のスラッシュにマッチします。
    例えば、<code>&lt;Location /abc/def&gt;</code> と指定し、
    <code>/abc//def</code> というリクエストがあれば、
    マッチすることになります。</p></note>

</usage>
<seealso>リクエストを受けた際にこれらの異なるセクションが
    組み合わされる方法については <a href="../sections.html">
    &lt;Directory&gt;, &lt;Location&gt;, &lt;Files&gt; セクションの動作法</a></seealso>
</directivesynopsis>

<directivesynopsis type="section">
<name>LocationMatch</name>
<description>囲んだディレクティブを正規表現にマッチする URL のみに
適用</description>
<syntax>&lt;LocationMatch
    <var>regex</var>&gt; ... &lt;/LocationMatch&gt;</syntax>
<contextlist><context>server config</context><context>virtual host</context>
</contextlist>

<usage>
    <p><directive type="section">LocationMatch</directive> ディレクティブは、
    <directive type="section" module="core">Location</directive> と同じ様に
    URL により中に書かれたディレクティブの適用範囲を制限します。
    但し、引数は普通の文字列ではなく、正規表現となります。例えば、</p>

    <example>
      &lt;LocationMatch "/(extra|special)/data"&gt;
    </example>

    <p>は URL に <code>/extra/data</code> か <code>/special/data</code>
    という文字列が含まれている場合にマッチします。</p>
</usage>

<seealso>リクエストを受けた際にこれらの異なるセクションが
    組み合わされる方法については <a href="../sections.html">
    &lt;Directory&gt;, &lt;Location&gt;, &lt;Files&gt; セクションの動作法</a></seealso>
</directivesynopsis>

<directivesynopsis>
<name>LogLevel</name>
<description>ErrorLog の冗長性を制御する</description>
<syntax>LogLevel <var>level</var></syntax>
<default>LogLevel warn</default>
<contextlist><context>server config</context><context>virtual host</context>
</contextlist>

<usage>
    <p><directive>LogLevel</directive> は、エラーログ (<directive module="core"
    >ErrorLog</directive> ディレクティブを
    見てください) へ記録するメッセージの冗長性を調整します。
    以下の <var>level</var> を指定でき、順に重要度が下がっていきます。</p>

    <table border="1">
      <tr>
        <th><strong>レベル</strong> </th>

        <th><strong>説明</strong> </th>

        <th><strong>例</strong> </th>
      </tr>

      <tr>
        <td><code>emerg</code> </td>

        <td>緊急 - システムが利用できない</td>

        <td>Child cannot open lock file. Exiting 
        (子プロセスがロックファイルを開けないため終了した)</td>
      </tr>

      <tr>
        <td><code>alert</code> </td>

        <td>直ちに対処が必要</td>

        <td>getpwuid: couldn't determine user name from uid
        (getpwuid: UID からユーザ名を特定できなかった)</td>
      </tr>

      <tr>
        <td><code>crit</code> </td>

        <td>致命的な状態</td>

        <td>socket: Failed to get a socket, exiting child
        (socket: ソケットが得られないため、子プロセスを終了させた)</td>
      </tr>

      <tr>
        <td><code>error</code> </td>

        <td>エラー</td>

        <td>Premature end of script headers
        (スクリプトのヘッダが足りないままで終わった)</td>
      </tr>

      <tr>
        <td><code>warn</code> </td>

        <td>警告</td>

        <td>child process 1234 did not exit, sending another SIGHUP
        (子プロセス 1234 が終了しなかった。もう一度 SIGHUP を送る)</td>
      </tr>

      <tr>
        <td><code>notice</code> </td>

        <td>普通だが、重要な情報</td>

        <td>httpd: caught SIGBUS, attempting to dump core in ...
        (httpd: SIGBUS シグナルを受け、... へコアダンプをした)</td>
      </tr>

      <tr>
        <td><code>info</code> </td>

        <td>追加情報</td>

        <td>"Server seems busy, (you may need to increase
        StartServers, or Min/MaxSpareServers)..." (「サーバは負荷が高い、
        (StartServers や Min/MaxSpareServers の値を増やす必要があるかも)」)</td>
      </tr>

      <tr>
        <td><code>debug</code> </td>

        <td>デバッグメッセージ</td>

        <td>"Opening config file ..." (設定ファイルを開いている...)</td>
      </tr>
    </table>

    <p>特定のレベルが指定された場合、それより高いレベルの全てのメッセージが
    報告されます。
    <em>例えば</em>、<code>LogLevel info</code> に指定すると、
    <code>notice</code> と <code>warn</code> も報告されます。</p>

    <p>なお <code>crit</code> 以上のレベルを指定することが推奨されます。</p>

    <p>例:</p>

    <example>
      LogLevel notice
    </example>

    <note><title>注</title>
      <p>ファイルにログを出力する場合、<code>notice</code>
      レベルのメッセージは抑制されず、すべてログに出力されます。
      しかし <code>syslog</code> を使用している場合は、
      これは当てはまりません。</p>
    </note>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>MaxKeepAliveRequests</name>
<description>持続的な接続上で許可されるリクエストの数</description>
<syntax>MaxKeepAliveRequests <var>number</var></syntax>
<default>MaxKeepAliveRequests 100</default>
<contextlist><context>server config</context><context>virtual host</context>
</contextlist>

<usage>
    <p><directive>MaxKeepAliveRequests</directive> ディレクティブは、
    <directive module="core">KeepAlive</directive> が有効な場合に、
    一回の接続で受け付け可能なリクエストの数を制限します。
    <code>0</code> に設定していれば、受け付けるリクエストは無制限になります。
    この設定は、サーバ性能を向上させるために、大きな数値を指定すること勧めます。
    </p>

    <p>例:</p>

    <example>
      MaxKeepAliveRequests 500
    </example>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>NameVirtualHost</name>
<description>名前ベースのバーチャルホストのための IP アドレスを指定</description>
<syntax>NameVirtualHost <var>addr</var>[:<var>port</var>]</syntax>
<contextlist><context>server config</context></contextlist>

<usage>
    <p><directive>NameVirtualHost</directive> ディレクティブは、
    <a href="../vhosts/">名前ベースのバーチャルホスト</a>の設定を行ないたい場合に
    必要となるものです。</p>

    <p><var>addr</var> にはホスト名を指定できますが、
    常に IP アドレスを指定するのが推奨されます。
    例えば、</p>

    <example>
      NameVirtualHost 111.22.33.44
    </example>

    <p><directive>NameVirtualHost</directive> ディレクティブは、
    名前ベースのバーチャルホストを
    利用してリクエストを受け付ける IP アドレスを指定します。
    これは、普通は名前ベースのバーチャルホストアドレスです。
    ただし、ファイアーウォールや他のプロキシがリクエストを受け付け、
    違う IP アドレスのサーバにフォワードするという場合は、
    リクエストを提供したいマシン上の物理インターフェースの
    IP アドレスを指定する必要があります。
    複数のアドレスで複数の名前ベースのバーチャルホストを指定する場合は
    各アドレスに対してディレクティブを書いてください。</p>

    <note><title>中</title>
      <p>「主サーバ」や、どの <code>_default_</code> サーバも、
      <directive>NameVirtualHost</directive> で指定した IP アドレスへのリクエスト
      を処理することは<strong>ありません</strong> (なぜか
      <directive>NameVirtualHost</directive> を
      指定したけどそのアドレスに <directive>VirtualHost</directive> を定義しなかった場合を除く)。</p>
    </note>

    <p>名前ベースのバーチャルホストにポート番号を指定することも可能です。
    例えば</p>

    <example>
      NameVirtualHost 111.22.33.44:8080
    </example>

    <p>IPV6 のアドレスは次の例のように角括弧で囲む必要があります:</p>
 
    <example>
      NameVirtualHost [2001:db8::a00:20ff:fea7:ccea]:8080
    </example>

    <p>すべてのインタフェースへのリクエストを受け取るようにするためには、
    引数として <code>*</code> を使います。</p>

    <example>
      NameVirtualHost *
    </example>

    <note><title><directive type="section">VirtualHost</directive> ディレクティブの引数</title>
      <p><directive type="section">VirtualHost</directive> ディレクティブの引数は <directive
      >NameVirtualHost</directive> ディレクティブの引数に正確に
      合っている必要があることに注意してください。</p>

      <example>
        NameVirtualHost 1.2.3.4<br />
        &lt;VirtualHost 1.2.3.4&gt;<br />
        # ...<br />
        &lt;/VirtualHost&gt;<br />
      </example>
    </note>

</usage>

<seealso><a href="../vhosts/">バーチャルホスト説明書
</a></seealso>

</directivesynopsis>

<directivesynopsis>
<name>Options</name>
<description>ディレクトリに対して使用可能な機能を設定する</description>
<syntax>Options
    [+|-]<var>option</var> [[+|-]<var>option</var>] ...</syntax>
<default>Options All</default>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context>
</contextlist>
<override>Options</override>

<usage>
    <p><directive>Options</directive> ディレクティブは、特定のディレクトリに対して
    どの機能が使用可能かを制御します。</p>

    <p><var>option</var> を <code>None</code>に指定すると、
    特別な機能は全て無効になります。
    また、以下の示す 1 個以上のものを指定できます。</p>

    <dl>
      <dt><code>All</code></dt>

      <dd><code>MultiViews</code> を除いた全ての機能が有効となります。
      これがデフォルトです。</dd>

      <dt><code>ExecCGI</code></dt>

      <dd>
      <module>mod_cgi</module> による CGI スクリプトの実行を許可します。</dd>

      <dt><code>FollowSymLinks</code></dt>

      <dd>
      サーバが、このディレクトリ内でシンボリックリンクをたどれるようにします。
      <note><p>サーバがシンボリックリンクをたどる場合でも、
      <directive type="section" module="core">Directory</directive> セクションに
      マッチさせるための
      パス名は<em>変更されません</em>。</p>
      <p><directive type="section" module="core">Location</directive> 内に
      このオプションを指定しても<strong>無視される</strong>ことに
      注意してください。</p></note></dd>

      <dt><code>Includes</code></dt>

      <dd>
      <module>mod_include</module> が提供する SSI を有効にします。</dd>

      <dt><code>IncludesNOEXEC</code></dt>

      <dd>
      SSI は有効になりますが、<code>#exec</code> コマンド と <code>#exec CGI</code> は無効になります。
      ただし、<code>#include virtual</code> により、<directive module="mod_alias">ScriptAlias</directive> されたディレクトリで
      CGI を実行することは可能です。</dd>

      <dt><code>Indexes</code></dt>

      <dd>
      もし、URL がディレクトリにマップするリクエストであって、
      且つ <directive module="mod_dir">DirectoryIndex</directive> で指定したファイル (例えば、<code>index.html</code>) が
      ディレクトリ内に無ければ、<module>mod_autoindex</module> が
      ディレクトリ内の一覧を整形して返します。</dd>

      <dt><code>MultiViews</code></dt>

      <dd>
      <module>mod_negotiation</module> による
      <a href="../content-negotiation.html">コンテントネゴシエーション</a> 
      された "MultiViews" を許可します。</dd>

      <dt><code>SymLinksIfOwnerMatch</code></dt>

      <dd>
      シンボリック先のファイルまたはディレクトリが、
      シンボリックリンクの所有ユーザ ID と同じ場合にのみシンボリックリンクを
      たどれるようにします。

      <note><title>注</title> <directive type="section" module="core"
      >Location</directive> 内にこのオプションを
      指定しても無視されます。</note>
      </dd>
    </dl>

    <p>通常、ディレクトリに対して複数の <directive>Options</directive> が
    適用可能な場合、
    最も近いもの一つのみが適用され、他のものは無視されます。
    複数の指定がマージされるわけではありません。(<a
    href="../sections.html#mergin">セクションのマージ方法</a>を参照してください。)
    しかし、すべての <directive>Options</directive> ディレクティブが <code>+</code> や <code>-</code> 付きで
    指定された場合はオプションの値はマージされます。
    <code>+</code> を頭につければ現在の設定に加えられ、
    <code>-</code> を付ければ現在の設定から削除されます。</p>

    <p>例えば、<code>+</code> や <code>-</code> を利用しない場合は:</p>

    <example>
      &lt;Directory /web/docs&gt;<br />
      <indent>
        Options Indexes FollowSymLinks<br />
      </indent>
      &lt;/Directory&gt;<br />
      <br />
      &lt;Directory /web/docs/spec&gt;<br />
      <indent>
        Options Includes<br />
      </indent>
      &lt;/Directory&gt;
    </example>

    <p><code>/web/docs/spec</code> というディレクトリには、
    <code>Includes</code> だけが適用されます。
    しかし、2 番目の <directive>Options</directive> で <code>+</code> や <code>-</code> を利用してみると:</p>
 
    <example>
      &lt;Directory /web/docs&gt;<br />
      <indent>
        Options Indexes FollowSymLinks<br />
      </indent>
      &lt;/Directory&gt;<br />
      <br />
      &lt;Directory /web/docs/spec&gt;<br />
      <indent>
        Options +Includes -Indexes<br />
      </indent>
      &lt;/Directory&gt;
    </example>

    <p><code>/web/docs/spec</code> というディレクトリには、 <code>FollowSymLinks</code> と
    <code>Includes</code> が適用されます。</p>

    <note><title>注</title>
      <p><code>-IncludesNOEXEC</code> もしくは
      <code>-Includes</code> を指定すると、
      前の設定がどのようになっていようとも SSI は無効となります。</p>
    </note>

    <p>どのような設定もされていなければ、デフォルトでは <code>All</code> に
    なります。</p>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>Require</name>
<description>どの認証済みユーザがリソースをアクセスできるかを選択する</description>
<syntax>Require <var>entity-name</var> [<var>entity-name</var>] ...</syntax>
<contextlist><context>directory</context><context>.htaccess</context>
</contextlist>
<override>AuthConfig</override>

<usage>
    <p>このディレクティブは、どの認証済みのユーザがディレクトリに
    アクセスすることができるかを指定します。
    以下のような構文になります。</p>

    <dl>
      <dt><code>Require user <var>userid</var> [<var>userid</var>] ...</code></dt>

      <dd>指定されたユーザのみ、ディレクトリへのアクセスを許可します。</dd>

      <dt><code>Require group <var>group-name</var> [<var>group-name</var>] ...</code></dt>

      <dd>指定されたグループに属するユーザのみ、ディレクトリへのアクセスを許可します。</dd>

      <dt><code>Require valid-user</code></dt>

      <dd>全ての認証されたユーザに、ディレクトリへのアクセスを許可します。</dd>
    </dl>

    <p><directive>Require</directive> は、正しく動作するためには <directive
    module="core">AuthName</directive> 及び <directive module="core"
    >AuthType</directive> ディレクティブや、
    (ユーザとグループを指定するために) <directive module="mod_auth"
    >AuthUserFile</directive> 及び <directive module="mod_auth"
    >AuthGroupFile</directive>
    といったディレクティブと共に
    指定する必要があります。
    例えば:</p>

    <example>
       AuthType Basic<br />
       AuthName "Restricted Directory"<br />
       AuthUserFile /web/users<br />
       AuthGroupFile /web/groups<br />
       Require group admin
    </example>

    <p>このようにして適用されたアクセス制御は、<strong>全ての</strong>メソッドに
    対して行なわれます。
    <strong>通常は、これが望ましい動作です。</strong>
    もし、特定のメソッドに対してのみアクセスの制御を適用し、
    他のメソッドは制限しない場合には、<directive
    type="section" module="core">Limit</directive> セクション内に
    <directive>Require</directive> を
    指定してください。</p>

</usage>
<seealso><directive module="core">Satisfy</directive></seealso>
<seealso><module>mod_access</module></seealso>
</directivesynopsis>

<directivesynopsis>
<name>RLimitCPU</name>
<description>Apache の子プロセスから起動されたプロセスの CPU 消費量を
制限する</description>
<syntax>RLimitCPU <var>seconds</var>|max [<var>seconds</var>|max]</syntax>
<default>未設定。オペレーティングシステムのデフォルトを使用</default>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context></contextlist>
<override>All</override>

<usage>
    <p>一つか二つのパラメータをとります。
    最初のパラメータは全プロセスに対するリソースのソフトリミットを設定し、
    2 番目のパラメータは最大のリソースリミットを設定します。
    パラメータには数字か、オペレーティングシステムの最大となる
    <code>max</code> のどちらかを指定することができます。
    最大のリソースリミットを上げるためには、サーバを
    <code>root</code> で実行するか起動されなければいけません。</p>

    <p>ちなみに、この設定は Apache の子プロセス自体ではなく、
    リクエストを受け付けた Apache の子プロセスから fork されたプロセスに
    適用されます。
    これには CGI や SSI から実行されたコマンドが含まれますが、Apache の
    親プロセスから fork されたログのパイププロセスなどには適用されません。</p>

    <p>CPU リソースのリミットはプロセスあたりの秒数で表わされます。</p>

</usage>
<seealso><directive module="core">RLimitMEM</directive></seealso>
<seealso><directive module="core">RLimitNPROC</directive></seealso>
</directivesynopsis>

<directivesynopsis>
<name>RLimitMEM</name>
<description>Apache の子プロセスから起動されたプロセスのメモリ消費量を
制限する</description>
<syntax>RLimitMEM <var>bytes</var>|max [<var>bytes</var>|max]</syntax>
<default>未設定。オペレーティングシステムのデフォルトを使用</default>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context></contextlist>
<override>All</override>

<usage>
    <p>一つか二つのパラメータををとります。
    最初のパラメータは全プロセスに対するリソースのソフトリミットを設定し、
    2 番目のパラメータは最大のリソースリミットを設定します。
    パラメータには数字か、オペレーティングシステムの最大となる
    <code>max</code> のどちらかを指定することができます。
    最大のリソースリミットを上げるためには、サーバを
    <code>root</code> で実行するか起動されなければいけません。</p>

    <p>この設定は Apache の子プロセス自体ではなく、
    リクエストを受け付けた Apache の子プロセスから fork されたプロセスに
    適用されます。
    これには CGI や SSI から実行されたコマンドが含まれますが、Apache の
    親プロセスから fork されたログのパイププロセスなどには適用されません。</p>

    <p>メモリリソースのリミットはプロセスあたりのバイト数で表わされます。</p>
</usage>
<seealso><directive module="core">RLimitCPU</directive></seealso>
<seealso><directive module="core">RLimitNPROC</directive></seealso>
</directivesynopsis>

<directivesynopsis>
<name>RLimitNPROC</name>
<description>Apache の子プロセスから起動されたプロセスが起動するプロセスの
数を制限する</description>
<syntax>RLimitNPROC <var>number</var>|max [<var>number</var>|max]</syntax>
<default>未設定。オペレーティングシステムのデフォルトを使用</default>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context></contextlist>
<override>All</override>

<usage>
    <p>一つか二つのパラメータをとります。
    最初のパラメータは全プロセスに対するリソースのソフトリミットを設定し、
    2 番目のパラメータは最大のリソースリミットを設定します。
    パラメータには数字か、オペレーティングシステムの最大となる
    <code>max</code> のどちらかを指定することができます。
    最大のリソースリミットを上げるためには、サーバを
    <code>root</code> で実行するか起動されなければいけません。</p>

    <p>この設定は Apache の子プロセス自体ではなく、
    リクエストを受け付けた Apache の子プロセスから fork されたプロセスに
    適用されます。
    これには CGI や SSI から実行されたコマンドが含まれますが、Apache の
    親プロセスから fork されたログのパイププロセスなどには適用されません。</p>

    <p>プロセスの制限は、ユーザあたりのプロセス数で制御されます。</p>

    <note><title>注</title>
      <p> CGI プロセスがウェブサーバのユーザ ID 以外で実行されるので
      <strong>無ければ</strong>、
      このディレクティブは、サーバ自身が生成できるプロセスの数を制限することになります。
      そのような状況になっているかどうかは、<code>error_log</code> 中の
      <strong><code>cannot fork</code></strong> というメッセージにより
      確認することができます。</p>
    </note>
</usage>
<seealso><directive module="core">RLimitMEM</directive></seealso>
<seealso><directive module="core">RLimitCPU</directive></seealso>
</directivesynopsis>

<directivesynopsis>
<name>Satisfy</name>
<description>ホストレベルのアクセス制御とユーザ認証との相互作用を指定</description>
<syntax>Satisfy Any|All</syntax>
<default>Satisfy All</default>
<contextlist><context>directory</context><context>.htaccess</context>
</contextlist>
<override>AuthConfig</override>
<compatibility>バージョン 2.0.51 以降では <directive module="core" type="section"
	>Limit</directive> ディレクティブと <directive module="core"
	type="section">LimitExcept</directive> ディレクティブの影響を受ける
</compatibility>

<usage>
    <p><directive module="mod_access">Allow</directive> と
    <directive module="core">Require</directive> の両方が使われているときの
    アクセスポリシーを設定します。パラメータは <code>All</code> か <code>Any</code>
    です。このディレクティブはある場所へのアクセスがユーザ名/パスワード
    <em>と</em>クライアントのホストのアドレスで制限されているときにのみ
    役立ちます。デフォルトの動作 (<code>All</code>) はクライアントがアドレスによる
    アクセス制限を満たし、<em>かつ</em>正しいユーザ名とパスワードを入力することを
    要求します。<code>Any</code> では、クライアントはホストの制限を満たすか、
    正しいユーザ名とパスワードの入力をするかをすればアクセスを許可されます。
    これは、ある場所をパスワードで保護するけれど、特定のアドレスからの
    クライアントにはパスワードの入力を要求せずにアクセスを許可する、
    というようなときに使用できます。</p>

    <p>例えば、同じネットワーク上にいる人にはウェブサイトのある部分について
    無制限のアクセスを許したいけれど、外のネットワークの人には
    パスワードを提供させるようにするためには、次のような設定をすることが
    できます:</p>

    <example>
    Require valid-user<br />
    Allow from 192.168.1<br />
    Satisfy Any
    </example>
   
    <p>バージョン 2.0.51 からは
    <directive module="core"
    type="section">Limit</directive> セクションと
    <directive module="core" type="section"
    >LimitExcept</directive> セクションを使用することで
    <directive>Satisfy</directive> ディレクティブが
    適用されるメソッドを制限することが
    できるようになりました。</p>
</usage>
   <seealso><directive module="mod_access">Allow</directive></seealso>
   <seealso><directive module="core">Require</directive></seealso>
</directivesynopsis>

<directivesynopsis>
<name>ScriptInterpreterSource</name>
<description>CGI スクリプトのインタープリタの位置を調べるための手法</description>
<syntax>ScriptInterpreterSource Registry|Registry-Strict|Script</syntax>
<default>ScriptInterpreterSource Script</default>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context></contextlist>
<override>FileInfo</override>
<compatibility>Win32 のみ。
オプション <code>Registry-Strict</code> は Apache 2.0 以降で使用可能</compatibility>

<usage>
    <p>このディレクティブは、Apache で CGI スクリプトを
    実行する場合に利用するインタープリタを、
    どのように探し出すかについて制御するために使用します。
    デフォルトの設定は <code>Script</code> です。これはスクリプトの
    shebang 行 (最初の行で <code>#!</code> から始まるもの)
    に指されているインタープリタを使用します。Win32 ではその行は
    以下の様になります。</p>

    <example>
      #!C:/Perl/bin/perl.exe
    </example>

    <p>もしくは、perl が <code>PATH</code> にある場合は単に:</p>

    <example>
      #!perl
    </example>

    <p><code>ScriptInterpreterSource Registry</code> を指定すると、
    スクリプトファイルの拡張子 (例えば、<code>.pl</code>) を
    キーとして、Windows のレジストリツリー <code>HKEY_CLASSES_ROOT</code>
    を検索するようになります。レジストリのサブキー
    <code>Shell\ExecCGI\Command</code> か、それが存在しない場合は
    <code>Shell\Open\Command</code> がスクリプトファイルを開くために
    使われます。レジストリキーが見つからないときは、Apache は <code>Script</code>
    オプションが指定されたときの動作に戻ります。</p>

    <note type="warning"><title>セキュリティ</title> 
    <p><code>ScriptInterpreterSource Registry</code> を <directive
    module="mod_alias">ScriptAlias</directive> されたディレクトリで使うときは
    注意してください。Apache はそのディレクトリ中の<em>すべての</em>ファイルを
    実行しようとします。<code>Registry</code> という設定は通常は実行されない
    ファイルに対して望ましくないプログラムの実行が発生する可能性があります。
    例えば、ほとんどの Windows システムで、
    <code>.htm</code> ファイルのデフォルトの「開く」コマンドは
    Microsoft Internet Explorer を実行しますので、スクリプトに指定された
    ディレクトリにある <code>.htm</code> ファイルへのリクエストはサーバの
    バックグラウンドでブラウザを実行することになります。これは、一分内くらいで
    システムをクラッシュさるための良い方法です。</p>
    </note>

    <p>Apache 2.0 から導入されたオプション <code>Registry-Strict</code> は
    <code>Registry</code> と同じことを行ないますが、サブキー
    <code>Shell\ExecCGI\Command</code> のみを使います。
    <code>ExecCGI</code> キーは普通に使われるキーではありません。Windows 
    レジストリに手動で設定する必要がありますので、システムでの偶発的なプログラムの
    実行を防ぐことができます。</p>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>ServerAdmin</name>
<description>サーバがクライアントに送るエラーメッセージに含める電子メールの
アドレス</description>
<syntax>ServerAdmin <var>email-address</var></syntax>
<contextlist><context>server config</context><context>virtual host</context>
</contextlist>

<usage>
    <p><directive>ServerAdmin</directive> は、クライアントに返すさまざまな
    エラーメッセージ中に記述する、
    電子メールアドレスを設定します。</p>

    <p>その際、これのために専用のアドレスを設定するのが良いでしょう。
    例えば、</p>

    <example>
      ServerAdmin www-admin@foo.example.com
    </example>

    <p>といったようにします。ユーザはいつもサーバに関する話であるということを
    明記してくるわけではありませんので。</p>

</usage>
</directivesynopsis>

<directivesynopsis>
<name>ServerAlias</name>
<description>リクエストを名前ベースのバーチャルホストにマッチさせているときに
使用されるホストの別名</description>
<syntax>ServerAlias <var>hostname</var> [<var>hostname</var>] ...</syntax>
<contextlist><context>virtual host</context></contextlist>

<usage>
    <p><directive>ServerAlias</directive> ディレクティブは、<a
    href="../vhosts/name-based.html">ネームベースのバーチャルホスト</a>において
    使用するホストの別名を指定します。</p>

    <example>
      &lt;VirtualHost *&gt;<br />
      ServerName server.domain.com<br />
      ServerAlias server server2.domain.com server2<br />
      # ...<br />
      &lt;/VirtualHost&gt;
    </example>
</usage>
<seealso><a href="../vhosts/">Apache バーチャルホスト説明書</a></seealso>
</directivesynopsis>

<directivesynopsis>
<name>ServerName</name>
<description>サーバが自分自身を示すときに使うホスト名とポート</description>
<syntax>ServerName <var>fully-qualified-domain-name</var>[:<var>port</var>]</syntax>
<contextlist><context>server config</context><context>virtual host</context>
</contextlist>
<compatibility>このディレクティブはバージョン 2.0 ではバージョン 1.3 の
    <directive>Port</directive> ディレクティブの機能も含みます。</compatibility>

<usage>
    <p><directive>ServerName</directive> ディレクティブは、
    サーバが自分自身を示すホスト名とポートを設定します。
    これは、リダイレクトする URL を生成する際に利用されます。
    例えば、ウェブサーバを動かしているマシンは <code>simple.example.com</code>
    で、DNS のエイリアス <code>www.example.com</code> もあるときに、
    ウェブサーバが後者として認識されて欲しいときは、以下のようにディレクティブを
    使います。</p>

    <example>
      ServerName www.example.com:80
    </example>

    <p><directive>ServerName</directive> が指定されていないときは、
    サーバは IP アドレスから逆引きを行なうことでホスト名を知ろうとします。
    <directive>ServerName</directive> にポートが指定されていないときは、
    サーバはリクエストが来ている
    ポートを使います。最高の信頼性と確実性をもたらすためには、
    <directive>ServerName</directive> を使ってホスト名とポートを明示的に
    指定してください。</p>

    <p><a href="../vhosts/name-based.html">名前ベースのバーチャルホスト</a>
    を利用している場合、<directive type="section" module="core"
    >VirtualHost</directive> セクション内の
    <directive>ServerName</directive> はこのバーチャルホストにマッチするために
    何がリクエストの Host: ヘッダに現れる必要があるのかを指定します。</p>

    <p>自己参照 URL (例えば <module>mod_dir</module> モジュールによるものなど)
    が指定されたポートを使うか、クライアントのリクエストのポート番号を使うかを
    決定する設定は <directive module="core">UseCanonicalName</directive> 
    ディレクティブを参照してください。</p>
</usage>

<seealso><a href="../dns-caveats.html">DNS と Apache に関する話</a></seealso>
<seealso><a href="../vhosts/">Apache バーチャルホスト説明書</a></seealso>
<seealso><directive module="core">UseCanonicalName</directive></seealso>
<seealso><directive module="core">NameVirtualHost</directive></seealso>
<seealso><directive module="core">ServerAlias</directive></seealso>
</directivesynopsis>

<directivesynopsis>
<name>ServerPath</name>
<description>非互換のブラウザが名前ベースのバーチャルホストにアクセスしたときの
ための互換用 URL パス名</description>
<syntax>ServerPath <var>URL-path</var></syntax>
<contextlist><context>virtual host</context></contextlist>

<usage>
    <p><directive>ServerPath</directive> ディレクティブは、<a
    href="../vhosts/">ネームベースのバーチャルホスト</a>において利用する
    互換用 URL パス名を設定します。</p>
</usage>
<seealso><a href="../vhosts/">Apache バーチャルホスト説明書</a></seealso>
</directivesynopsis>

<directivesynopsis>
<name>ServerRoot</name>
<description>インストールされたサーバのベースディレクトリ</description>
<syntax>ServerRoot <var>directory-path</var></syntax>
<default>ServerRoot /usr/local/apache</default>
<contextlist><context>server config</context></contextlist>

<usage>
    <p><directive>ServerRoot</directive> ディレクティブは、
    サーバが存在するディレクトリを設定します。
    通常、<code>conf/</code> や <code>logs/</code> といったサブディレクトリが
    存在します。
    また、他の設定ファイルにおける相対パスは、このディレクトリからとなります。</p>

    <example><title>例</title>
      ServerRoot /home/httpd
    </example>


</usage>
<seealso><a href="../invoking.html"><code>httpd</code> の <code>-d</code>
    オプション</a></seealso>
<seealso><directive>ServerRoot</directive> の権限を適切に設定する方法は<a
     href="../misc/security_tips.html#serverroot">セキュリティのこつ</a></seealso>
</directivesynopsis>

<directivesynopsis>
<name>ServerSignature</name>
<description>サーバが生成するドキュメントのフッタを設定</description>
<syntax>ServerSignature On|Off|EMail</syntax>
<default>ServerSignature Off</default>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context>
</contextlist>
<override>All</override>

<usage>
    <p><directive>ServerSignature</directive> ディレクティブは、
    サーバが生成するドキュメント
    (エラーメッセージ、<module>mod_proxy</module> における FTP のディレクトリリスト、
    <module>mod_info</module> の出力、等々)
    の最下行に付与するフッタの設定を行ないます。
    そのようなフッタ行を有効にしたい理由には、
    プロキシが複数連なっている場合に、ユーザはどのサーバが返した
    エラーメッセージかを知る手段がほとんど無いというものがあります。</p>


    <p>デフォルトである <code>Off</code> に設定をすると、フッタ行が抑制されます
    (そして、Apache-1.2 以前と互換の動作をします)。
    <code>On</code> に設定した場合は、単にドキュメントの中に、サーバのバージョン、
    稼動中のバーチャルホストの <a
    href="#servername">ServerName</a> の書かれた行を追加し、
    <code>EMail</code> にした場合はさらに参照されたドキュメントに対する <a
    href="#serveradmin">ServerAdmin</a> を指す "mailto:" が追加されます。</p>

    <p>バージョン 2.0.44 以降ではこのディレクティブは <directive
    module="core">ServerSignature</directive>
    ディレクティブにより表示される情報も制御します。</p>
</usage>
<seealso><directive module="core">ServerTokens</directive></seealso>
</directivesynopsis>

<directivesynopsis>
<name>ServerTokens</name>
<description>Server HTTP 応答ヘッダを設定する</description>
<syntax>ServerTokens Major|Minor|Min[imal]|Prod[uctOnly]|OS|Full</syntax>
<default>ServerTokens Full</default>
<contextlist><context>server config</context></contextlist>

<usage>
    <p>このディレクティブは、クライアントに送り返す <code>Server</code>
    応答ヘッダ内に、サーバの一般的な OS 種別や、
    コンパイルされて組み込まれているモジュールの情報を
    含めるかどうかを指定します。</p>

    <dl>
      <dt><code>ServerTokens Prod[uctOnly]</code></dt>

      <dd>サーバは (例えば): <code>Server:
      Apache</code> といったように送ります。</dd>

      <dt><code>ServerTokens Major</code></dt>

      <dd>Server sends (<em>e.g.</em>): <code>Server:
      Apache/2</code></dd>

      <dt><code>ServerTokens Minor</code></dt>

      <dd>Server sends (<em>e.g.</em>): <code>Server:
      Apache/2.0</code></dd>

      <dt><code>ServerTokens Min[imal]</code></dt>

      <dd>サーバは (例えば): <code>Server:
      Apache/2.0.41</code> といったように送ります。</dd>

      <dt><code>ServerTokens OS</code></dt>

      <dd>サーバは (例えば): <code>Server: Apache/2.0.41
      (Unix)</code> といったように送ります。</dd>

      <dt><code>ServerTokens Full</code> (もしくは未指定)</dt>

      <dd>サーバは (例えば): <code>Server: Apache/2.0.41
      (Unix) PHP/4.2.2 MyMod/1.2</code> といったように送ります。</dd>
    </dl>

    <p>この設定はサーバ全体に適用され、バーチャルホスト上で有効にしたり
    無効にしたりはできません。</p>

    <p>バージョン 2.0.44 以降ではこのディレクティブは <directive
    module="core">ServerSignature</directive>
    ディレクティブにより表示される情報も制御します。</p>
</usage>
<seealso><directive module="core">ServerSignature</directive></seealso>
</directivesynopsis>

<directivesynopsis>
<name>SetHandler</name>
<description>マッチするファイルがハンドラで処理されるようにする</description>
<syntax>SetHandler <var>handler-name</var>|None</syntax>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context>
</contextlist>
<override>FileInfo</override>
<compatibility>Apache 2.0 で core に移動</compatibility>

<usage>
    <p><code>.htaccess</code> や <directive type="section" module="core"
    >Directory</directive>
    セクション、<directive type="section" module="core">Location</directive>
    セクションに書かれた場合、
    このディレクティブはそこにあるすべてのファイルが
    <var>handler-name</var> で指定された<a href="../handler.html"
    >ハンドラ</a>で扱われることを強制します。例えば、拡張子に関わらず、
    ディレクトリ全体がイメージマップファイルとして解析して欲しい場合には、
    以下をそのディレクトリの <code>.htaccess</code>
    ファイルに記述します:</p>

    <example>
      SetHandler imap-file
    </example>

    <p>別の例: URL <code>http://servername/status</code>
    が指定されたときにサーバが状態報告をするようにしたいときは、以下を
    <code>httpd.conf</code> に記述します:</p>

    <example>
      &lt;Location /status&gt;<br />
      <indent>
        SetHandler server-status<br />
      </indent>
      &lt;/Location&gt;
    </example>

    <p><code>None</code> という値を設定することで、
    前の方の <directive>SetHandler</directive> で定義された設定を無効にすることが
    できます。</p>

</usage>

<seealso><directive module="mod_mime">AddHandler</directive></seealso>

</directivesynopsis>

<directivesynopsis>
<name>SetInputFilter</name>
<description>クライアントのリクエストや POST の入力を処理するフィルタを設定する</description>
<syntax>SetInputFilter <var>filter</var>[;<var>filter</var>...]</syntax>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context>
</contextlist>
<override>FileInfo</override>

<usage>
    <p><directive>SetInputFilter</directive> ディレクティブはクライアントの
    リクエストや POST の入力をサーバが受け取ったときに処理するフィルタを
    設定します。これは <directive module="mod_mime">AddInputFilter</directive>
    ディレクティブを含め、他の場所で定義されているフィルタの設定に
    追加されます。</p>

    <p>複数のフィルタを指定するときは、データを処理する順番に
    セミコロンで区切る必要があります。</p>

</usage>
<seealso><a href="../filter.html">フィルタ</a>説明書</seealso>
</directivesynopsis>

<directivesynopsis>
<name>SetOutputFilter</name>
<description>サーバの応答を処理するフィルタを設定する</description>
<syntax>SetOutputFilter <var>filter</var>[;<var>filter</var>...]</syntax>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context>
</contextlist>
<override>FileInfo</override>

<usage>
    <p><directive>SetOutputFilter</directive> ディレクティブは
    サーバの応答をクライアントに送り返される前に処理するフィルタを設定します。
    これは <directive module="mod_mime">AddOutputFilter</directive>
    ディレクティブを含め、他の場所で定義されているフィルタの設定に
    追加されます。</p>    

    <p>例えば、以下の設定は <code>/www/data/</code> ディレクトリのすべての
    ファイルを SSI で処理します。</p>

    <example>
      &lt;Directory /www/data/&gt;<br />
      <indent>
        SetOutputFilter INCLUDES<br />
      </indent>
      &lt;/Directory&gt;
    </example>

    <p>複数のフィルタを指定するときは、データを処理する順番に
    セミコロンで区切る必要があります。</p>
</usage>
<seealso><a href="../filter.html">フィルタ</a>説明書</seealso>
</directivesynopsis>

<directivesynopsis>
<name>TimeOut</name>
<description>各イベントについて、リクエストを失敗させるまでにサーバが
待つ時間を設定</description>
<syntax>TimeOut <var>seconds</var></syntax>
<default>TimeOut 300</default>
<contextlist><context>server config</context></contextlist>

<usage>
    <p><directive>TimeOut</directive> ディレクティブは、現在のところ
    以下の三つの待ち時間についての定義を行います:</p>

    <ol>
      <li>GET リクエストを受け取るのにかかる総時間</li>

      <li>POST や PUTリクエストにおいて、次の TCP パケットが届くまでの待ち時間</li>

      <li>レスポンスを返す際、TCP の ACK が帰ってくるまでの時間</li>
    </ol>
    
    <p>将来には別々の設定をすることが可能にできるよう考慮中です。
    Apache 1.2 以前はタイマーは 1200 がデフォルトでしたが、
    300 に下げられました。300 でもほとんどの場合は十分すぎる値です。
    コード中の変な場所にまだパケットを送る際にタイマをリセットしない
    場所があるかもしれないので、デフォルトをより小さい値にはしていません。</p>

</usage>
</directivesynopsis>

<directivesynopsis>
<name>UseCanonicalName</name>
<description>サーバが自分自身の名前とポートを決定する方法を設定する</description>
<syntax>UseCanonicalName On|Off|Dns</syntax>
<default>UseCanonicalName On</default>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context></contextlist>

<usage>
    <p>多くの状況で Apache は<em>自己参照</em> URL、すなわち
    同じサーバを指す URL、を作成する必要があります。
    <code>UseCanonicalName On</code> を使うと (1.3 より前の
    すべてのバージョンでも) Apache は <a
    href="#servername">ServerName</a> ディレクティブと <a href="#port">Port</a>
    ディレクティブを使ってサーバの正式な名前を作成します。
    この名前がすべての自己参照 URL で使われ、CGI の <code>SERVER_NAME</code>
    と <code>SERVER_PORT</code> にも使われます。</p>

    <p><code>UseCanonicalName Off</code> では Apache は
    クライアントがホスト名とポートを提供した場合には自己参照 URL を
    それらを元に作成します (提供されていない場合は上で定義されているように
    正式な名前を使います)。
    これらの値は<a href="../vhosts/name-based.html">名前ベースの
    バーチャルホスト</a>を実装するのに使われているのと同じ値で、
    同じクライアントから取得できる値です。CGI 変数 <code>SERVER_NAME</code>
    と <code>SERVER_PORT</code> もクライアントから与えられた値から
    作成されます。</p>

    <p>これが有用な場合の例は、イントラネットのサーバで、<code>www</code> の
    ような短い名前でユーザがマシンに接続しているときです。
    ユーザが短い名前を入力して、URL が<em>最後のスラッシュ無しの</em>ディレクトリ
    へのものであるときに、Apache はリクエストを
    <code>http://www.domain.com/splat/</code> へリダイレクトすることに
    気付くでしょう。認証をするように設定していると、この場合
    ユーザは 2 回認証をしなければならなくなります (<code>www</code> に
    対して 1 回、<code>www.domain.com</code> に対してもう一回 -- 
    より詳しい情報は <a 
    href="http://httpd.apache.org/docs/misc/FAQ.html#prompted-twice">この話題の
    FAQ</a> を参照してください)。
    しかし、<directive>UseCanonicalName</directive> が <code>Off</code> になっていると、
    Apache は <code>htttp://www/splat/</code> にリダイレクトします。</p>

    <p>三つ目のオプション <code>UseCanonicalName DNS</code> は、
    <code>Host:</code> ヘッダを提供しない古いクライアントをサポートした
    大規模な IP ベースのバーチャルホスティングで使用されることを
    意図しています。このオプションでは、Apache はクライアントが
    接続した IP アドレスに DNS の逆引きを行なって自己参照 URL を
    作成します。</p>

    <note type="warning"><title>警告</title>
    <p>CGI が <code>SERVER_NAME</code> に
    関する仮定を行なっているときは、このオプションの設定で動作しなく
    なるかもしれません。クライアントは実質的にはホスト名にとして
    何でも望みの値を指定することができます。CGI が
    <code>SERVER_NAME</code> のみを使って自己参照 URL を作成している
    場合はどの設定を行なっても大丈夫なはずです。</p></note>
</usage>
<seealso><directive module="core">ServerName</directive></seealso>
<seealso><directive module="mpm_common">Listen</directive></seealso>
</directivesynopsis>

<directivesynopsis type="section">
<name>VirtualHost</name>
<description>特定のホスト名や IP アドレスのみに適用されるディレクティブを
囲む</description>    
<syntax>&lt;VirtualHost
    <var>addr</var>[:<var>port</var>] [<var>addr</var>[:<var>port</var>]]
    ...&gt; ... &lt;/VirtualHost&gt;</syntax>
<contextlist><context>server config</context></contextlist>

<usage>
    <p><directive type="section">VirtualHost</directive> 及び
    <code>&lt;/VirtualHost&gt;</code> は、
    特定のバーチャルホストに対してのみ適用されるディレクティブ群を括る
    ために使われます。
    バーチャルホストコンテキストで許可される全てのディレクティブを指定可能です。
    サーバが、指定されたバーチャルホストにあるドキュメントへの
    リクエストを受け付けた場合、
    <directive type="section">VirtualHost</directive> セクションの中にある
    ディレクティブが適用されます。
    <var>Addr</var>は、次のものが利用できます:</p>

    <ul>
      <li>バーチャルホストの IP アドレス</li>

      <li>バーチャルホストの IP に対応する完全なドメイン名</li>

      <li><code>NameVirtualHost *</code> と共に使われる、
      すべての IP アドレスにマッチする文字 <code>*</code></li>

      <li>IP ベースのバーチャルホストで他のものにマッチしない IP アドレス
      のための文字列 <code>_default_</code></li>
    </ul>

    <example><title>例</title>
      &lt;VirtualHost 10.1.2.3&gt;<br />
      <indent>
        ServerAdmin webmaster@host.foo.com<br />
        DocumentRoot /www/docs/host.foo.com<br />
        ServerName host.foo.com<br />
        ErrorLog logs/host.foo.com-error_log<br />
        TransferLog logs/host.foo.com-access_log<br />
      </indent>
      &lt;/VirtualHost&gt;
    </example>    
 
    <p>IPv6 アドレスはオプションのポート番号の指定と区別するために、
    角括弧で括って指定する必要があります。次は IPv6 の例です:</p>

    <example>
      &lt;VirtualHost [2001:db8::a00:20ff:fea7:ccea]&gt;<br />
      <indent>
        ServerAdmin webmaster@host.example.com<br />
        DocumentRoot /www/docs/host.example.com<br />
        ServerName host.example.com<br />
        ErrorLog logs/host.example.com-error_log<br />
        TransferLog logs/host.example.com-access_log<br />
      </indent>
      &lt;/VirtualHost&gt;
    </example>  

    <p>各々のバーチャルホストにはそれぞれ違う IP アドレス、ポート番号
    もしくはホスト名に対応する必要があり、
    1 番目の場合には複数のアドレスで IP パケットを受信できるように
    サーバマシンを設定しなければなりません。
    (もし、マシンが複数のネットワークインターフェースと持たない場合は、
    (OSがサポートしていれば) <code>ifconfig alias</code> コマンドにより
    達成できます)。</p>

    <p><code>:port</code> といった形式で記述することにより、
    マッチさせるポートを変更可能です。
    この指定をしない場合には、主サーバ設定における
    一番最後に <code><a href="#port">Port</a></code> で指定されたポートが
    デフォルトとなります。
    <code>:*</code> を指定することにより、
    アドレス上の全てのポートにマッチします。(<code>_default_</code> のときは
    これを使うことが推奨されています。)</p>

    <p><strong>セキュリティに関して</strong>: 
    サーバーを起動した以外のユーザがログファイルが保管されるディレクトリに
    書き込み可能なときになぜセキュリティが破られる可能性があるかの詳細は
    <a href="../misc/security_tips.html">セキュリティに関するコツ</a> を
    参照してください。</p>
    
    <note><title>注意点</title>
    <p><directive type="section">VirtualHost</directive> は Apache が Listen する
    IP アドレスには影響を与え<strong>ません</strong>。
    <directive module="mpm_common">Listen</directive> を
    使って Apache が正しいアドレスを listen するように設定する必要があります。</p>
    </note>

    <p>IP ベースのバーチャルホストを使っている場合は、特別な名前
    <code>_default_</code> を指定することができます。その場合は
    そのバーチャルホストは他のバーチャルホストで明示的に挙げられていない
    すべての IP アドレスにマッチします。<code>_default_</code> バーチャルホストが無い
    場合に IP がバーチャルホストで指定されたものにマッチしないときは、
    VirtualHost セクションの外のすべての定義からなる「主」サーバ設定が
    使われます。(ただし、<directive
    module="core">NameVirtualHost</directive> ディレクティブにマッチする
    すべての IP アドレスは「主」サーバ設定も <code>_default_</code> バーチャルホストも
    使わないことに注意してください。詳しくは <a
    href="../vhosts/name-based.html">ネームベースのバーチャルホスト</a> を
    参照してください。)</p>

    <p><code>:port</code> といった形式で記述することにより、
    マッチさせるポートを変更可能です。
    この指定をしない場合には、主サーバ設定における
    一番最後に <directive module="mpm_common">Listen</directive> で指定された
    ポートがデフォルトとなります。
    <code>:*</code> を指定することにより、
    アドレス上の全てのポートにマッチします。(<code>_default_</code> のときは
    これを使うことが推奨されています。)</p>

    <p><code>:port</code> といった形式で記述することにより、
    マッチさせるポートを変更可能です。
    この指定をしない場合には、主サーバ設定における
    一番最後に <code><a href="#port">Port</a></code> で指定されたポートが
    デフォルトとなります。
    <code>:*</code> を指定することにより、
    アドレス上の全てのポートにマッチします。(<code>_default_</code> のときは
    これを使うことが推奨されています。)</p>

    <note type="warning"><title>セキュリティ</title>
    <p>サーバーを起動した以外のユーザがログファイルが保管されるディレクトリに
    書き込み可能なときになぜセキュリティが破られる可能性があるかの詳細は
    <a href="../misc/security_tips.html">セキュリティに関するコツ</a> を
    参照してください。</p></note>
</usage>
<seealso><a href="../vhosts/">Apache バーチャルホスト説明書</a></seealso>
<seealso><a href="../dns-caveats.html">DNS と Apache に関する話</a></seealso>
<seealso><a href="../bind.html">Apache が使用するアドレスとポートの設定</a></seealso>
<seealso>リクエストを受けた際にこれらの異なるセクションが
    組み合わされる方法については <a href="../sections.html">
    &lt;Directory&gt;, &lt;Location&gt;, &lt;Files&gt; セクションの動作法</a></seealso>
</directivesynopsis>

</modulesynopsis>
