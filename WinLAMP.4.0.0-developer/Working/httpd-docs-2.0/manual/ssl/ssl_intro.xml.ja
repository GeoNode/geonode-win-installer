<?xml version='1.0' encoding='iso-2022-jp' ?>
<!DOCTYPE manualpage SYSTEM "../style/manualpage.dtd">
<?xml-stylesheet type="text/xsl" href="../style/manual.ja.xsl"?>
<!-- English Revision: 396609 -->

<!--
 Copyright 2003-2004 The Apache Software Foundation

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->

<manualpage metafile="ssl_intro.xml.meta">
<parentdocument href="./">SSL/TLS</parentdocument>

  <title>SSL/TLS 暗号化: はじめに</title>

<summary>
<blockquote>
<p>標準規格の良い所は、たくさんの規格から選べるということだ。
そして、もし本当にどの規格も気に入らなければ、
一年待つだけで探していた規格が現れる。</p>

<p class="cite">-- <cite>A. Tanenbaum</cite>, "Introduction to
Computer Networks"</p>
</blockquote>

<p>
入門ということで、この章は Web、HTTP、Apache に通じている
読者向けですが、セキュリティ専門家向けではありません。
SSL プロトコルの決定的な手引きであるつもりはありません。
また、組織内の認証管理のための特定のテクニックや、
特許や輸出規制などの重要な法的な問題についても扱いません。
むしろ、更なる研究への出発点として色々な概念、定義、例を並べることで
 mod_ssl のユーザに基礎知識を提供する事を目的としています。</p>

<p>ここに示された内容は主に、原著者の許可の下
The Open Group Research Institute の <a
href="http://home.earthlink.net/~fjhirsch/">Frederick J. Hirsch</a>
 氏の記事 <a
href="http://home.earthlink.net/~fjhirsch/Papers/wwwj/article.html">
Introducing SSL and Certificates using SSLeay</a> を基にしています。
氏の記事は <a
href="http://www.ora.com/catalog/wjsum97/">Web Security: A Matter of
Trust</a>, World Wide Web Journal, Volume 2, Issue 3, Summer 1997
に掲載されました。
肯定的な意見は <a
href="mailto:hirsch@fjhirsch.com">Frederick Hirsch</a> 氏
 (元記事の著者) へ全ての苦情は <a
href="mailto:rse@engelschall.com">Ralf S. Engelschall</a> (
<module>mod_ssl</module> の作者) へお願いします。
[訳注: 訳については <a
href="mailto:apache-docs@ml.apache.or.jp">
Apache ドキュメント翻訳プロジェクト</a>
へお願いします。]</p>
</summary>

<section id="cryptographictech">
<title>暗号化技術</title>
<p>SSL を理解するには、暗号アルゴリズム、
メッセージダイジェスト関数(別名: 一方向関数、ハッシュ関数)、
電子署名などへの理解が必要です。
これらの技術は本が丸ごと必要な題目で
(例えば [<a href="#AC96">AC96</a>] を参照)、
プライバシー、信用、認証などの技術の基礎となっています。</p>

<section id="cryptographicalgo">
<title>暗号アルゴリズム</title>
    <p>例えば、アリスが送金のために銀行にメッセージを送りたいとします。
    口座番号や送金の金額が含まれるため、
    アリスはそのメッセージを秘密にしたいと思います。
    解決方法の一つは暗号アルゴリズムを使って、メッセージを
    読ませたい人以外は読むことができない暗号化された
    形態に変えてしまうことです。
    その形態になると、
    メッセージは秘密の鍵によってのみ解釈することができます。
    鍵なしでは、メッセージは役に立ちません。
    良い暗号アルゴリズムは、侵入者が元のテキストを解読することを
    非常に難しくするため、努力が割に合わなくさせます。</p>

    <p>暗号アルゴリズムには
    従来型と公開鍵の二つの種類があります。</p>

    <dl>
    <dt>従来型暗号</dt>
    <dd>対称暗号としても知られ、
    送信者と受信者が鍵を共有することが必要です。
    鍵とは、メッセージを暗号化したり復号するのに使われる秘密
    の情報のことです。
    もし、この鍵が秘密なら、送信者と受信者以外は誰もメッセージを読
    むことができません。
    もしも、アリスと銀行が秘密の鍵を知っているなら、
    彼らはお互いに秘密のメッセージを送ることができるでしょう。
    ただし、事前に内密に鍵を選ぶという仕事は問題を含んでいます。</dd>

    <dt>公開鍵暗号</dt>
    <dd>非対称暗号としても知られ、
    メッセージを暗号化することのできる二つの鍵
    を使用するアルゴリズムを定義することで鍵のやり取りの問題を解決
    します。
    もし、ある鍵が暗号化に使われたなら、
    もう片方の鍵で復号しなければいけません。
    この方式によって、一つの鍵を公表して(公開鍵)、
    もう片方を秘密にしておく(秘密鍵)だけで、
    安全なメッセージを受け取ることができます。</dd>
    </dl>

    <p>誰もが暗号化されたメッセージを公開鍵によって暗号化
    することができますが、秘密鍵の持ち主だけがそれを読むことが
    できます。
    この方法で、銀行の公開鍵を使って暗号化することで、
    アリスは秘密のメッセージを送ることができます。
    銀行のみが復号することができます。</p>
</section>

<section id="messagedigests">
<title>メッセージダイジェスト</title>
    <p>アリスはメッセージを秘密にすることができますが、
    誰かが例えば自分に送金するようにメッセージを変更したり、
    別のものに置き換えてしまうかもしれないという問題があります。
    アリスのメッセージの信用を保証する方法の一つは、
    メッセージの簡潔なダイジェストを作って、それも銀行に送るというものです。
    メッセージを受け取ると銀行もダイジェストを作成し、
    アリスが送ったものと比べます。もし一致したなら、
    受け取ったメッセージは無傷だということになります。</p>

    <p>このような要約は<dfn>メッセージダイジェスト</dfn>、
    <em>一方行関数</em>、または<em>ハッシュ関数</em>と呼ばれます。
    メッセージダイジェストは長い可変長のメッセージから
    短い固定長の表現を作るのに使われます。
    ダイジェストアルゴリズムはメッセージから
    一意なダイジェストを生成するように作られています。
    メッセージダイジェストはダイジェストから元のメッセージを
    判定するのがとても難しいようにできています。
    また、同じ要約を作成する二つのメッセージを探すのは不可能です。
    よって、同じ要約を使ってメッセージを置き換えるという
    可能性を排除しています。</p>

<p>アリスへのもう一つの問題は、このダイジェストを安全に送る方法を探すことです。
これができれば、メッセージの信用が保証されます。
一つの方法はこのダイジェストに電子署名を含むことです。</p>
</section>

<section id="digitalsignatures"><title>電子署名</title>
<p>アリスが銀行にメッセージを送ったとき、銀行は、
侵入者が彼女になりすまして彼女の口座への取引を申請していないか、
メッセージが本当に彼女からのものか確実に分からなければいけません。
アリスによって作成され、メッセージに含まれた
<em>電子署名</em>がここで役に立ちます。</p>

<p>電子署名はメッセージのダイジェストやその他の情報(処理番号など)を
送信者の秘密鍵で暗号化することで作られます。
誰もが公開鍵を使って署名を<em>復号</em>することができますが、
署名者のみが秘密鍵を知っています。
これは、彼らのみが署名しえたことを意味します。
ダイジェストを電子署名に含むことは、
その署名がそのメッセージのみに有効であることを意味します。
これは、誰もダイジェストを変えて署名をすることができないため、
メッセージの信用も保証します。</p>

<p>侵入者が署名を傍受して後日に再利用するのを防ぐため
電子署名には一意な処理番号が含まれます。
これは、アリスがそんなメッセージは送っていないと言う詐欺
から銀行を守ります。
彼女だけが署名しえたからです。(否認防止)</p>
</section>
</section>
<!-- /cryptographictech -->

<section id="certificates">
<title>証明書</title>
<p>アリスは秘密のメッセージを銀行に送り、
署名をして、メッセージの信用を保証することができるおうになりましたが、
通信している相手が本当に銀行なのか確かめなくてはいけません。
これは、彼女が使う公開鍵が銀行の秘密鍵と対になっているものか、
彼女は確かめなくてはいけないということを意味します。
同様に、銀行はメッセージの署名が本当にアリスの署名か確認する必要が
あります。</p>

<p>もし両者に身元を証明し、公開鍵を確認し、また信頼された機関が署名
した証明書があれば、両者とも通信相手について正しい相手だと
確信することができます。
そのような信頼された機関は<em>認証局</em>
 (Certificate Authority または CA) と呼ばれ、
証明書 (certificate) が認証 (authentication) に使われます。</p>

<section id="certificatecontents">
<title>証明書の内容</title>
    <p>証明書は公開鍵と個人、サーバ、その他の主体の実在の身元を
    関連付けます。
    <a href="#table1">表1</a>に示されるように証明対象の情報は
    身元証明の情報(識別名)と公開鍵が含まれます。
    証明書はまた、認証局の身元証明と署名、そして証明書の有効期間を
    含みます。
    シリアルナンバーなどの認証局の管理上の情報や
    その他の追加の情報が含まれているかもしれません。</p>

    <section id="table1">
    <title>表1: 証明書情報</title>
    <table>
    <columnspec><column width=".35"/><column width=".35"/>
    </columnspec>
    <tr><th>証明対象</th>
        <td>識別名、公開鍵</td></tr>
    <tr><th>発行者</th>
        <td>識別名、公開鍵</td></tr>
    <tr><th>有効期間</th>
        <td>開始日、失効日</td></tr>
    <tr><th>管理情報</th>
        <td>バージョン、シリアルナンバー</td></tr>
    <tr><th>拡張情報</th>
        <td>基本的な制約、ネットスケープフラッグ、その他</td></tr>
    </table>
    </section>

    <p>識別名(ディスティングイッシュ・ネーム)は特定の状況における
    身分証明を提供するのに使われています。例えば、ある人は
    私用と会社とで別々の身分証明を持つかもしれません。
    
    識別名は X.509 標準規格 [<a
    href="#X509">X509</a>] で定義されています。
    X.509 標準規格は、項目、項目名、そして項目の略称を定義しています。(<a href="#table2">表
    2</a> 参照)</p>

    <section id="table2">
    <title>表 2: 識別名情報</title>
    <table border="1">
    <columnspec><column width=".25"/><column width=".15"/>
      <column width=".3"/><column width=".25"/></columnspec>
    <tr><th>識別名項目</th>
        <th>略称</th>
        <th>説明</th>
        <th>例</th></tr>
    <tr><td>Common Name (コモンネーム)</td>
        <td>CN</td>
        <td>認証される名前<br />
        SSL接続するURL</td>
        <td>CN=www.example.com</td></tr>
    <tr><td>Organization or Company (組織名)</td>
        <td>O</td>
        <td>団体の正式英語組織名</td>
        <td>O=Example Japan K.K.</td></tr>
    <tr><td>Organizational Unit (部門名)</td>
        <td>OU</td>
        <td>部署名など</td>
        <td>OU=Customer Service</td></tr>
    <tr><td>City/Locality (市区町村)</td>
        <td>L</td>
        <td>所在してる市区町村</td>
        <td>L=Sapporo</td></tr>
    <tr><td>State/Province (都道府県)</td>
        <td>ST</td>
        <td>所在してる都道府県</td>
        <td>ST=Hokkaido</td></tr>
    <tr><td>Country(国)</td>
        <td>C</td>
        <td>所在している国名の ISO コード<br />
        日本の場合 JP
        </td>
        <td>C=JP</td></tr>
    </table>
    </section>

    <p>認証局はどの項目が省略可能でどれが必須かの方針を定義する
    かもしれません。項目の内容についても認証局や証明書のユーザからの
    要件があるかもしれません。
    例えば、ネットスケープのブラウザはサーバの証明書の
     Common Name (コモンネーム)がサーバのドメイン名の
     <code>*.example.com</code> 
    というようなワイルドカードのパターンにマッチすること
    を要求します。</p>

    <p>バイナリ形式の証明書は ASN.1 表記法
     [<a href="#X208">X208</a>] [<a href="#PKCS">PKCS</a>] で
    定義されています。
    この表記法は内容をどのように記述するかを定義し、
    符号化の規定がこの情報がどのようにバイナリ形式に変換されるかを
    定義します。
    証明書のバイナリ符号化は Distinguished Encoding
    Rules (DER) で定義され、それはより一般的な Basic Encoding Rules
    (BER) に基づいています。
    バイナリ形式を扱うことのできない送信では、
    バイナリ形式は Base64 符号化 [<a href="#MIME">MIME</a>] で
    ASCII 形式に変換されることがあります。
    このように符号化され、以下の例に示されるように区切り行に
    挟まれたものは PEM 符号化されたと言います。
    (PEM の名前は "Privacy Enhanced Mail" に由来します)</p>

    <example>
    <title>PEM 符号化された証明書の例 (example.crt)</title>
    <pre>-----BEGIN CERTIFICATE-----
MIIC7jCCAlegAwIBAgIBATANBgkqhkiG9w0BAQQFADCBqTELMAkGA1UEBhMCWFkx
FTATBgNVBAgTDFNuYWtlIERlc2VydDETMBEGA1UEBxMKU25ha2UgVG93bjEXMBUG
A1UEChMOU25ha2UgT2lsLCBMdGQxHjAcBgNVBAsTFUNlcnRpZmljYXRlIEF1dGhv
cml0eTEVMBMGA1UEAxMMU25ha2UgT2lsIENBMR4wHAYJKoZIhvcNAQkBFg9jYUBz
bmFrZW9pbC5kb20wHhcNOTgxMDIxMDg1ODM2WhcNOTkxMDIxMDg1ODM2WjCBpzEL
MAkGA1UEBhMCWFkxFTATBgNVBAgTDFNuYWtlIERlc2VydDETMBEGA1UEBxMKU25h
a2UgVG93bjEXMBUGA1UEChMOU25ha2UgT2lsLCBMdGQxFzAVBgNVBAsTDldlYnNl
cnZlciBUZWFtMRkwFwYDVQQDExB3d3cuc25ha2VvaWwuZG9tMR8wHQYJKoZIhvcN
AQkBFhB3d3dAc25ha2VvaWwuZG9tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKB
gQDH9Ge/s2zcH+da+rPTx/DPRp3xGjHZ4GG6pCmvADIEtBtKBFAcZ64n+Dy7Np8b
vKR+yy5DGQiijsH1D/j8HlGE+q4TZ8OFk7BNBFazHxFbYI4OKMiCxdKzdif1yfaa
lWoANFlAzlSdbxeGVHoT0K+gT5w3UxwZKv2DLbCTzLZyPwIDAQABoyYwJDAPBgNV
HRMECDAGAQH/AgEAMBEGCWCGSAGG+EIBAQQEAwIAQDANBgkqhkiG9w0BAQQFAAOB
gQAZUIHAL4D09oE6Lv2k56Gp38OBDuILvwLg1v1KL8mQR+KFjghCrtpqaztZqcDt
2q2QoyulCgSzHbEGmi0EsdkPfg6mp0penssIFePYNI+/8u9HT4LuKMJX15hxBam7
dUHzICxBVC1lnHyYGjDuAMhe396lYAn8bCld1/L4NMGBCQ==
-----END CERTIFICATE-----</pre>
    </example>
</section>

<section id="certificateauthorities">
<title>認証局</title>
    <p>まず証明書の申請の情報を確認することで、
    認証局は秘密鍵の持ち主の身元を保証します。
    例えば、アリスが個人証明書を申請したとすると、
    認証局はアリスが証明書の申請が主張する通りの
    人物だということを確認しなくてはいけません。</p>

    <section id="certificatechains">
    <title>証明書階層構造</title>
        <p>認証局は他の認証局への証明書を発行することができます。
        未知の証明書を調べる時に、アリスはその証明書の発行者
        に自信が持てるまで、発行者の証明書を
        その上位階層の認証局をたどって調べる必要があります。
        「悪質な」証明書の危険性を減らすため、
        彼女は限られた連鎖の発行者のみ信頼するように
        決めることもできます。</p>
    </section>

    <section id="rootlevelca">
    <title>最上位認証局の作成</title>
        <p>前に述べたように、全ての証明書について、
        最上位の認証局(CA)までそれぞれの発行者が
        対象の身元証明の有効性を明らかにする必要があります。
        問題は、誰がその最上位の認証機関の証明書を保証するのか、
        ということです。
        このような場合に限り、証明書は「自己署名」されます。
        つまり、証明書の発行者と証明対象が同じということになります。
        その結果、自己署名された証明書を信用するには
        細心の注意が必要です。
        最上位認証局が公開鍵を広く公表することで、
        その鍵を信頼するリスクを低くすることができます。
        もし、他人がその認証局になりすました時に、それが露見しや
        すいからです。
        多くのブラウザは有名な認証局を信頼するように
        設定されています。</p>

        <p><a href="http://www.thawte.com/">Thawte</a> 
        や <a href="http://www.verisign.com/">VeriSign</a> 
        のような多くの会社が認証局として開設しました。
        このような会社は以下のサービスを提供します:</p>

        <ul>
        <li>証明書申請の確認</li>
        <li>証明書申請の処理</li>
        <li>証明書の発行と管理</li>
        </ul>

        <p>自分で認証局を作ることも可能です。
        インターネット環境では危険ですが、
        個人やサーバの身元証明が簡単に行える組織の
        イントラネット内では役に立つかもしれません。</p>
    </section>

    <section id="certificatemanagement">
    <title>証明書管理</title>
        <p>認証局の開設は徹底した管理、技術、運用の体制を必要とする
        責任のある仕事です。
        認証局は証明書を発行するだけでなく、
        管理もしなければなりません。
        具体的には、証明書がいつまで有効かを決定し、更新し、
        また既に発行されたが失効した証明書のリスト
        (Certificate Revocation Lists または CRL)
        を管理しなければいけません。
        例えば、アリスが会社から社員として証明書を与えられたとします。
        そして、アリスが会社を辞めるときには証明書を取り消さなければ
        いけないとします。
        証明書は次々と人に渡されていくものなので、
        証明書そのものから、それが取り消されたか判断することは
        不可能です。
        よって、証明書の有効性を調べるときには、
        認証局に連絡して CRL を照合する必要があります。
        普通この過程は自動化されているものではありません。</p>

        <note><title>注意</title>
        <p>デフォルトでブラウザに設定されていない認証局を使った場合、
        認証局の証明書をブラウザに読み込んで、
        ブラウザがその認証局によって署名されたサーバの証明書を
        有効化する必要があります。
        一度読み込まれると、その認証局によって署名された全ての
        証明書を受け入れるため、危険を伴います。</p>
        </note>
    </section>
</section>
<!-- /certificateauthorities -->
</section>
<!-- /certificates -->

<section id="ssl">
<title>Secure Sockets Layer (SSL)</title>
<p>Secure Sockets Layer プロトコルは信頼性のあるコネクション型の
ネットワーク層のプロトコル(例えば、TCP/IP)と
アプリケーション層のプロトコル(例えば、HTTP)
の間に置くことができます。
SSL は、相互認証によってサーバとクライアント間の安全な通信を、
電子署名によってデータの完全性を、
そして暗号化によってプライバシを提供します。</p>

<p>SSL プロトコルは暗号化、ダイジェスト、電子署名について、
様々なアルゴリズムをサポートするようにできています。
こうすることで、法や輸出の規制を考慮に入れて、サーバに合わせた
アルゴリズムを選ぶことができ、また、新しいアルゴリズムを
利用していくことも可能にしています。
アルゴリズムの選択はプロトコルセッション開始時に
サーバとクライアント間で取り決められます。</p>

<section id="table4">
<title>表4: SSL プロトコルのバージョン</title>
    <table border="1">
    <columnspec><column width=".15"/><column width=".2"/>
     <column width=".30"/><column width=".25"/></columnspec>
    <tr><th>バージョン</th>
        <th>出典</th>
        <th>説明</th>
        <th>ブラウザのサポート</th></tr>
    <tr><td>SSL v2.0</td>
        <td>Vendor Standard (Netscape Corp. より) [<a href="#SSL2"
        >SSL2</a>]</td>
        <td>実装が現存する初めての SSL プロトコル</td>
        <td>- NS Navigator 1.x/2.x<br />
        - MS IE 3.x<br />
        - Lynx/2.8+OpenSSL</td></tr>
    <tr><td>SSL v3.0</td>
        <td>Expired Internet Draft (Netscape Corp. より) [<a href="#SSL3"
        >SSL3</a>]</td>
        <td>特定のセキュリティ攻撃を防ぐための改訂、
        非RSA 暗号の追加、証明書階層構造のサポート</td>
        <td>- NS Navigator 2.x/3.x/4.x<br />
        - MS IE 3.x/4.x<br />
        - Lynx/2.8+OpenSSL</td></tr>
    <tr><td>TLS v1.0</td>
        <td>Proposed Internet Standard (IETF より) [<a href="#TLS1"
        >TLS1</a>]</td>
        <td>MAC レイヤを HMAC へ更新、ブロック暗号の block
        padding、メッセージ順序の標準化、警告文の充実などのため
        SSL 3.0 を改訂。</td>
        <td>- Lynx/2.8+OpenSSL</td></tr>
    </table>
</section>

<p><a href="#table4">表4</a>に示されるとおり、SSL プロトコルには
いくつものバージョンがあります。
表にも書かれているように、SSL 3.0 の利点の一つは
証明書階層構造をサポートすることです。
この機能によって、サーバは自分の証明書に加えて、
発行者の証明書をブラウザに渡すことができます。
証明書階層構造によって、
ブラウザに発行者の証明書が直接登録されていなくても、
階層の中に含まれていれば、
ブラウザはサーバの証明書を有効化することができます。
SSL 3.0 は現在 Internet Engineering Task Force (IETF) 
によって開発されている Transport Layer Security 
[<a href="#TLS1">TLS</a>] プロトコル標準規格の基礎となっています。</p>

<section id="session">
<title>セッションの確立</title>
    <p><a href="#figure1">図1</a>で示されるように、
    セッションの確立はクライアントとサーバ間の
    ハンドシェークシークエンスによって行なわれます。
    サーバが証明書を提供するか、クライアントの証明書をリクエストするか
    というサーバの設定により、このシークエンスは異なるものとなります。
    暗号情報の管理のために、追加のハンドシェーク過程が必要になる
    場合もありますが、この記事では
    よくあるシナリオを手短に説明します。
    全ての可能性についは、SSL 仕様書を参照してください。</p>

    <note><title>注意</title>
    <p>一度 SSL セッションが確立すると、セッションを再利用することで、
    セッションを開始するための多くの過程を繰り返すという
    パフォーマンスの損失を防ぎます。
    そのため、サーバは全てのセッションに一意なセッション識別名を
    割り当て、サーバにキャッシュし、クライアントは次回から
    (識別名がサーバのキャッシュで期限切れになるまでは)
    ハンドシェークなしで接続することができます。</p>
    </note>

    <p class="figure">
    <img 
    src="../images/ssl_intro_fig1.gif" alt="" width="423" height="327" /><br />
    <a id="figure1" name="figure1"><dfn>図1</dfn></a>: SSL
    ハンドシェークシークエンス概略</p>

    <p>サーバとクライアントで使われる
    ハンドシェークシークエンスの要素を以下に示します:</p>

    <ol>
    <li>データ通信に使われる暗号スイートの取り決め</li>
    <li>クライアントとサーバ間でのセッション鍵の確立と共有</li>
    <li>オプションとして、クライアントに対するサーバの認証</li>
    <li>オプションとして、サーバに対するクライアントの認証</li>
    </ol>

    <p>第一ステップの暗号スイート取り決めによって、
    サーバとクライアントはそれぞれにあった
    暗号スイートを選ぶことができます。
    SSL3.0 プロトコルの仕様書は 31 の暗号スイートを定義しています。
    暗号スイートは以下のコンポーネントにより定義されています:</p>

    <ul>
    <li>鍵の交換手段</li>
    <li>データ通信の暗号術</li>
    <li>Message Authentication Code (MAC) 作成のための
    メッセージダイジェスト</li>
    </ul>

    <p>これらの三つの要素は以下のセクションで説明されています。</p>
</section>

<section id="keyexchange">
<title>鍵の交換手段</title>
    <p>鍵の交換手段はアプリケーションのデータ通信に使われ、
    共有される対称暗号鍵をどのようにがクライアントとサーバで
    取り決めるかを定義します。
    SSL 2.0 は RSA 鍵交換しか使いませんが、
    SSL 3.0 は証明書が使われるときは RSA 鍵交換を使い、
    証明書が無く、クライアントとサーバの事前の通信が無い場合は
    Diffie-Hellman 鍵交換を使う
    など様々な鍵交換アルゴリズムをサポートします。</p>

    <p>鍵の交換方法における一つの選択肢は電子署名です。
    電子署名を使うかどうか、また、
    どの種類の署名を使うかという選択があります。
    秘密鍵で署名することで共有鍵を生成すし、情報交換する時の
    マン・イン・ザ・ミドル攻撃を防ぐことができます。
    [<a href="#AC96">AC96</a>, p516]</p>
</section>

<section id="ciphertransfer">
<title>データ通信の暗号術</title>
    <p>SSL はセッションのメッセージの暗号化に前述した
    従来型暗号(対称暗号)を用います。
    暗号化しないという選択肢も含め九つの選択肢があります:</p>

    <ul>
    <li>暗号化なし</li>
    <li>ストリーム暗号
        <ul>
        <li>40-bit 鍵での RC4</li>
        <li>128-bit 鍵での RC4</li>
        </ul></li>
    <li>CBC ブロック暗号
        <ul><li>40 bit 鍵での RC2</li>
        <li>40 bit 鍵での DES</li>
        <li>56 bit 鍵での DES</li>
        <li>168 bit 鍵での Triple-DES</li>
        <li>Idea (128 bit 鍵)</li>
        <li>Fortezza (96 bit 鍵)</li>
        </ul></li>
    </ul>

    <p>ここでの CBC とは暗号ブロック連鎖 (Cipher Block Chaining)
     の略で、一つ前の暗号化された暗号文の一部が
    ブロックの暗号化に使われることを意味します。
    DES はデータ暗号化標準規格 (Data Encryption Standard)
     [<a href="#AC96">AC96</a>, ch12] の略で、
    DES40 や 3DES_EDE を含むいくつもの種類があります。
    Idea は最高なものの一つで、暗号術的には現在ある中で
    最も強力なものです。
    RC2 は RSA DSI による独占的なアルゴリズムです。
     [<a href="#AC96">AC96</a>,
    ch13]</p>
</section>

<section id="digestfuntion">
<title>ダイジェスト関数</title>
    <p>
    ダイジェスト関数の選択はレコードユニットからどのようにダイジェストが生成されるかを決定します。
    SSL は以下をサポートします:</p>

    <ul>
    <li>ダイジェストなし</li>
    <li>MD5 (128-bit ハッシュ)</li>
    <li>Secure Hash Algorithm (SHA-1) (160-bit ハッシュ)</li>
    </ul>

    <p>メッセージダイジェストは Message Authentication Code (MAC) 
    の生成に使われ、メッセージと共に暗号化され、メッセージの信用を
    提供し、リプレイ攻撃を防ぎます。</p>
</section>

<section id="handshake">
<title>ハンドシェークシークエンスプロトコル</title>
    <p>ハンドシェークシークエンスは三つのプロトコルを使います:</p>

    <ul>
    <li><dfn>SSL ハンドシェークプロトコル</dfn>は
    クライアントとサーバ間での SSL セッションの確立に使われます。</li>
    <li><dfn>SSL 暗号仕様変更プロトコル</dfn>は
    セッションでの暗号スイートの取り決めに使われます。</li>
    <li><dfn>SSL 警告プロトコル</dfn>は
    クライアントサーバ間で SSL エラーを伝達するのに使われます。</li>
    </ul>

    <p>三つのプロトコルは、アプリケーションプロトコルデータとともに、
    <a href="#figure2">図2</a>に示すとおり <dfn>SSL レコードプロトコル</dfn>
    でカプセル化されます。
    カプセル化されたプロトコルはデータを検査しない
    下層のプロトコルによってデータとして伝達されます。
    カプセル化されたプロトコルは下層のプロトコルに関して一切関知しません。</p>

    <p class="figure">
    <img src="../images/ssl_intro_fig2.gif" alt="" width="428"
        height="217" /><br />
    <a id="figure2" name="figure2"><dfn>図2</dfn></a>: SSL プロトコルスタック
    </p>

    <p>
    レコードプロトコルによる SSL コントロールプロトコルのカプセル化は、
    アクティブなセッションの二回目の通信があった場合、
    コントロールプロトコルが安全であることを意味します。
    既にセッションが無い場合は、Null 暗号スイートが使われ、
    暗号化は行なわれず、セッションが確立するまでは
    ダイジェストも無い状態となります。</p>
</section>

<section id="datatransfer">
<title>データ通信</title>
    <p><a href="#figure3">図3</a>に示される SSL レコードプロトコル
    はクライアントとサーバ間のアプリケーションや
    SSL コントロールデータの通信に使われます。
    このデータはより小さいユニットに分けられたり、
    いくつかの高級プロトコルをまとめて一ユニットとして通信が
    行なわれることもあります。
    データを圧縮し、ダイジェスト署名を添付して、
    これらのユニットを暗号化したのち、ベースとなっている
    信頼性のあるトランスポートプロトコルを用いるかもしれません。
    (注意: 現在メジャーな SLL 実装で圧縮をサポートしているものはありません)</p>

    <p class="figure">
    <img src="../images/ssl_intro_fig3.gif" alt="" width="423"
        height="323" /><br />
    <a id="figure3" name="figure3"><dfn>図 3</dfn></a>: SSL レコードプロトコル
    </p>
</section>

<section id="securehttp">
<title>HTTP 通信の安全化</title>
    <p>よくある SSL の使い方はブラウザとウェブサーバ間の HTTP 通信
    の安全化です。
    これは、従来の安全ではない HTTP の使用を除外するものではありません。
    安全化されたものは主に SSH 上の普通の HTTP で、HTTPS と呼ばれます。
    大きな違いは、URL スキームに <code>http</code> の代わりに <code>https</code>
    を用い、サーバが別のポートを使うことです (デフォルトでは443)。
    これが主に <module
    >mod_ssl</module> が Apache ウェブサーバに提供する機能です。</p>
</section>
</section>
<!-- /ssl -->

<section id="references">
<title>参考文献</title>
<dl>
<dt><a id="AC96" name="AC96">[AC96]</a></dt>
<dd>Bruce Schneier, <q>Applied Cryptography</q>, 2nd Edition, Wiley,
1996. See <a href="http://www.counterpane.com/"
>http://www.counterpane.com/</a> for various other materials by Bruce
Schneier.</dd>

<dt><a id="X208" name="X208">[X208]</a></dt>
<dd>ITU-T Recommendation X.208, <q>Specification of Abstract Syntax Notation
One (ASN.1)</q>, 1988. See for instance <a
href="http://www.itu.int/rec/recommendation.asp?type=items&amp;lang=e&amp;parent=T-REC-X.208-198811-I"
>http://www.itu.int/rec/recommendation.asp?type=items&amp;lang=e&amp;parent=T-REC-X.208-198811-I</a>.
</dd>

<dt><a id="X509" name="X509">[X509]</a></dt>
<dd>ITU-T Recommendation X.509, <q>The Directory - Authentication
Framework</q>. See for instance <a
href="http://www.itu.int/rec/recommendation.asp?type=folders&amp;lang=e&amp;parent=T-REC-X.509"
>http://www.itu.int/rec/recommendation.asp?type=folders&amp;lang=e&amp;parent=T-REC-X.509</a>.
</dd>

<dt><a id="PKCS" name="PKCS">[PKCS]</a></dt>
<dd><q>Public Key Cryptography Standards (PKCS)</q>, 
RSA Laboratories Technical Notes, See <a
href="http://www.rsasecurity.com/rsalabs/pkcs/"
>http://www.rsasecurity.com/rsalabs/pkcs/</a>.</dd>

<dt><a id="MIME" name="MIME">[MIME]</a></dt>
<dd>N. Freed, N. Borenstein, <q>Multipurpose Internet Mail Extensions
(MIME) Part One: Format of Internet Message Bodies</q>, RFC2045.
See for instance <a href="http://ietf.org/rfc/rfc2045.txt"
>http://ietf.org/rfc/rfc2045.txt</a>.</dd>

<dt><a id="SSL2" name="SSL2">[SSL2]</a></dt>
<dd>Kipp E.B. Hickman, <q>The SSL Protocol</q>, 1995. See <a
href="http://www.netscape.com/eng/security/SSL_2.html"
>http://www.netscape.com/eng/security/SSL_2.html</a>.</dd>

<dt><a id="SSL3" name="SSL3">[SSL3]</a></dt>
<dd>Alan O. Freier, Philip Karlton, Paul C. Kocher, <q>The SSL Protocol
Version 3.0</q>, 1996. See <a
href="http://www.netscape.com/eng/ssl3/draft302.txt"
>http://www.netscape.com/eng/ssl3/draft302.txt</a>.</dd>

<dt><a id="TLS1" name="TLS1">[TLS1]</a></dt>
<dd>Tim Dierks, Christopher Allen, <q>The TLS Protocol Version 1.0</q>,
1999. See <a href="http://ietf.org/rfc/rfc2246.txt"
>http://ietf.org/rfc/rfc2246.txt</a>.</dd>
</dl>
</section>
<!-- /references -->

</manualpage>
